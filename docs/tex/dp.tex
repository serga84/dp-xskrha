% preambule dokumentu
\documentclass[12pt]{article}
‎\usepackage[czech]{babel}
\usepackage[utf8]{inputenc}
\usepackage[pdfborder=0]{hyperref}
\usepackage{dipp2}
%\usepackage{stencl/dipp_utf}
%\usepackage{graphicx}
%\usepackage{textcomp}
%\usepackage{amssymb}
%\usepackage{amsmath}
%\usepackage{eurosym}
\pagestyle{headings}

\begin{document}


% uvodni cast zaverecne prace
\titul{Webová architektura v prostředí vysoké zátěže}{Bc. Jakub Škrha}{Ing. Michael Štencl, Ph.D.}{Brno 2012}
\podekovani{Chtěl bych poděkovat svému vedoucímu Ing. Michaelu Štenclovi, Ph.D., za odborné vedení této diplomové práce. Zejména bych chtěl poděkovat Ondřeji Procházkovi za konzultace a nasměrování pro vyřešení praktické části, která díky tomu odráží použití v reálném produkčním prostředí. Také bych chtěl poděkovat Lucii Palkoskové za trpělivost a podporu při psaní této diplomové práce a své rodině za podporu při celém mém studiu.}

\prohlaseni{Prohlašuji, že jsem tuto práci napsal a vyřešil samostatně s použitím literatury, kterou uvádím v seznamu.}{V Brně dne 21.5.2012}

\abstract{\textsc{Skrha, J.} \textit{Web architecture in high load environment.} 
Diploma thesis. Brno, 2012.}
{This diploma thesis describes web architecture in high load environment. The thesis contains description of layers, theirs purpose and functionality of web architecture. The aim of thesis is optimalization on individual layers, particularly on application layer, database layer, application distributed cache layer and reverse proxy cache layer. For these layers, presented solutions are based on real production projects such as Linux Debian, Apache2, PHP, PostgreSQL, Memcached and Nginx.}

\abstrakt{\textsc{Škrha, J.} \textit{Webová architektura v prostředí vysoké zátěže.} 
Diplomová práce. Brno, 2012.}
{Tato diplomová práce popisuje webovou architekturu v prostředí vysoké zátěže. V práci jsou popsány její vrstvy, jejich účel a funkčnost pro webovou architekturu. Práce se zabývá možností optimalizace na jednotlivých vrstvách webové architektury, zejména aplikační vrstvou, databázovou vrstvou, aplikační distribuovanou cache vrstvou a reverzní proxy cache vrstvou. Pro tyto vrstvy jsou uvedena vybraná řešení odrážející reálné produkční nasazení v prostředí Linux Debian, Apache2, PHP, PostgreSQL, Memcached a Nginx.}


\obsah
\cislovat{3}


% Uvod
\kapitola{Úvod}
V 80. letech 20. století, tedy ve dnech, kdy vznikal internet, nikdo netušil, že jeho význam, důležitost a popularita tak markantně vzroste. Dnes, v 2. dekádě 21. století, je internet a web nedílnou součástí firem, organizací, komunikace, zábavy, zpravodajství, obchodu, služeb a života běžných lidí. Internet se stává důležitou vědeckou disciplínou nejenom na poli informačních technologií. Internetem se zabývají oblasti vývoje hardware a software, počítačové sítě, aplikační a komunikační protokoly, uživatelská rozhraní a design, ekonomika a marketing, copywriting, projektové řízení, databázové systémy a mnoho dalších odvětví. Jednou z oblastí je i webová architektura v prostředí vysoké zátěže.

Úspěch internetových a webových projektů je přímo úměrný výši návštěvnosti, míře používání, počtu registrací a samozřejmě výdělku z aplikace. Obecně se dá předpokládat, že čím je větší návštěvnost projektu, tím jsou větší i zisky. Ať už díky reklamní činnosti či placenným službám. Ovšem zde se dá velice jasně konstatovat, že tyto výdělky nejsou až tak lehce získané. Nejenom, že si musí aplikace získat své uživatele, ale musí řešit problémy s obrovským počtem uživatelů. Tím vzniká prostředí vysoké zátěže pro webovou architekturu, které je potřeba optimalizovat.

\sekce{Cíl práce}
Cílem této práce je provést rozbor webové architektury, jejich vrstev, možností optimalizace a provést srovnání dílčích řešení v prostředí vysoké zátěže. Práce se zaměřuje na řešení serverové části webové architektury. Úkolem je vytvořit prototyp serverové části webové architektury s aplikační vrstvou, databázovou vrstvou a cache vrstvou a nasimulovat prostředí vysoké zátěže. Je potřeba navrhnout a implementovat řešení optimalizací jednotlivých vrstev serverové části a porovnat výsledky před a po optimalizaci. Důležitou součástí této práce se má stát aplikace s plnou podporou ukládání a čtení aplikačních a databázových dat pomocí paměti cache. Výstupem mají být jednotlivé výsledky zátěžových testů a profilovacích charakteristik srovnávajících dílčí způsoby řešení.

% Nezadouci vlivy
\kapitola{Nežádoucí vlivy a důsledky vysoké zátěže}
Vysoká zátěž může mít ve své podstatě několik nežádoucích vlivů, které můžou mít až katastrofický scénář. Může docházet k takovému zatížení aplikace, že odpovědi na jednotlivé požadavky mohou trvat velmi dlouhou dobu. Tím pádem se bude uživatel rozhodovat, zda-li příště navštíví tuto webovou aplikaci, či zkusí některou z jiných možných konkurenčních alternativ. Tento velice nepříznivý scénář může být ještě horší. A to v případě, že díky velkému zatížení dojde dokonce k výpadku celé aplikace, a tím pádem už se uživateli nedostane vůbec žádné odpovědi na jeho požadavek. Při takovém scénáři existuje vysoká pravděpodobnost ztráty uživatelů, což může znamenat velký pokles zisků pro firmu či společnost.

Po technické stránce se při velké zátěži vytvoří pro každý požadavek celý samostatný proces či vlákno procesu, které si klade nároky na procesor CPU a operační paměť RAM serveru. Vznikají tak i procesy, které musí čekat na přidělení těchto prostředků, a tím pádem roste zatížení, které může server vytížit do té míry, že nebude provozuschopný. Takové zatížení je možné pozorovat při výpisu právě běžících procesů a jejich vytížení na RAM či CPU (například příkazem top). Dále je možno pozorovat tzv. Load Average (například příkazem uptime), které představuje počet procesů čekajících na přidělení prostředků během jedné, pěti či patnácti minut. Takto je možné sledovat nežádoucí vlivy vysoké zátěže na úrovni jednotlivých serverů.\cite{sledovani-zatizeni}

Je nutné podotknout, že existuje i jeden skrytý a ne tak viditelný důsledek vysoké zátěže. Tím je fakt, že jakmile se začne zvedat návštěvnost, projektové vedení si klade požadavek, aby tento nárůst uživatelů již zůstal, a dokonce se i zvětšoval. A to vše z toho důvodu, že velký počet uživatelů znamená sice velkou zátěž pro aplikaci, ovšem také velký finanční přínos pro firmu.



% Zneuziti
\kapitola{Zneužití vysoké zátěže}
Z nežádoucích vlivů a důsledků uvedených v předchozí kapitole vyplývá, že rostoucí zátěž může způsobit katastrofické scénáře, čili může negativně působit na celou aplikaci. Tento poznatek představuje obrovské riziko při jeho zneužití. Zpravidla může být zneužití vysoké zátěže způsobeno úmyslným či neúmyslným chováním nějaké organizace či jedince. Takové zneužití má svoji oporu i v zákonech, kde hrozí až odnětí svobody až na několik let.

U webových projektů je možné z těch neúmyslných zneužití zmínit například některé klientské chyby programů či větší míru indexace robotů internetových vyhledáváčů. Roboti vyhledávačů pravidelně prochází webovou aplikaci a indexují její jednotlivé části a tyto výsledky zohledňují následně ve svých výsledcích ve vyhledávání. Tito roboti jsou tak součástí vytížení architektury.

Tím druhým, a daleko nebezpečnějším, úmyslným způsobem zneužití lze mnohdy způsobit daleko větší škody. Toto úmyslné chování už je klasifikováno jako útok na webovou aplikaci za který hrozí postih podle zákona. Tyto útoky jsou nazývány DoS, neboli Denial of Service. Jejich cílem je ochromit infrastrukturu celé webové architektury přehlcením požadavků, na které aplikace bude vytvářet odpovědi. Tyty útoky využívají chyb, nedostatků či nedokonalostí protokolů ICMP, TCP, UDP a jiných protokolů či samotných webových aplikací. Například útok s názvem Tcp Syn Flood, při kterém útočník vytíží aplikaci SYN pakety pro navázání spojení, využívá nedokonalosti TCP protokolu. Dalšími útoky využívajícími nedokonalostí mohou být ICMP Flood, Ping of Death, Smurf Attack, IP Spoofing, Fraggle Attack, Teardrop, Application level aj. Ovšem proti většině zmíněných útoků už dnes existuje ochrana ve formě servisních aktualizací systémů a programů nebo lehké konfigurace jednotlivých částí aplikace. \cite{dos}

Co ovšem v dnešní době představuje daleko větší nebezpečí, jsou útoky typu DDoS, neboli Distributed Denial of Service. V tomto případě je princip útoku obdobný jako u DoS, ovšem s tím rozdílem, že je distribuovaný. Takový útok je spuštěn z několika stanic, několika uživateli a pomocí různých nástrojů. Tento způsob je daleko organizoavnější a daleko nebezpečnější a učinnější. \cite{dos}

V současnosti se stává symbolem boje za svobodu internetu skupina s názvem Anonymous, která využívá útoků DDoS. Při svých útocích využívají například útoky typu Slowloris, kdy útočník využívá protokolu HTTP na aplikační úrovni a vyžaduje celou odpověď na svůj požadavek. Při navázaném spojení ovšem odesílá HTTP hlavičky co nejpomaleji, aby tak co nejvíce prodloužili dobu spojení a získal prostor pro vytvoření dalšího spojení, čili další zátěže. Tato skupina napadá webové aplikace veřejností neoblíbených politických stran, vládních organizací, protipirátských asociací a jiných subjektů. Díky tomu si získávají obrovskou podporu ve společnosti i médiích, která s jejich kroky souhlasí. Dokonce pro své útoky využívají i příznivců z řad veřejnosti, kteří nemusí být specialisty v oboru informačních technologií. Stačí jim pouze stáhnout si upravený program, v určený čas ho spustit a připojit se do internetové sítě. Útoky probíhají neohlášeně, organizovaně a ditribuovaně. Otázkou zůstává, kdy jejich konání zaštiťující se honosnými cíli, přeroste ve vydírání, snahy o posílení moci, či pokusů o finanční obohacení. V ten moment i společnost, která je v tyto dny podporuje, může pocítit jejich nebezpečnost. I v historii lidstva nalezneme spoustu skupin a organizací, které byly lidmi podporovány a nakonec se z nich stal symbol krutosti, tyranie, útlaku a neštěstí. Proto je důležité jejich útoky nepodceňovat a umět se bránit. Tato práce se nezabývá konkrétním řešením některého z typů útoků, ale zabývá se obecně vysokou zátěží, a způsoby, kterými lze ustát obrovský narůst zátěže, tedy i nějaký útok. \cite{anonymous}



% Tri a vice vrstev
\kapitola{Tří a vícevrstvá architektura webových systémů}
Webová architektura je ve svém základu třívrstvá. První vrstvu tvoří klient, neboli uživatel, se svým hardware, software a svými aplikačními požadavky. Druhou vrstvu tvoří aplikační vrstva, která zpracovává požadavky pro aplikaci, tedy požadavky klienta. Aplikační vrstva tento požadavek zpracuje, vytvoří odpověď a zašle zpět klientovi. Ovšem k tomu, aby mohla tuto odpověď vytvořit, potřebuje i data aplikace, která jsou uložena v perzistentní databázi, která tvoří třetí a poslední vrstvu třívrstvé architektury. Každá z vrstev, tedy prezentační, aplikační i datová, má své místo a význam v aplikaci.\cite{tri-vrstvy}

\obrazek
\vlozeps{../images/3layer.png}{0.5}
\endobr{Tří vrstvá architektura webových aplikací}

V architektuře webových aplikací s vysokou zátěží už je potřeba jiný přístup. V tomto případě se dá říci, že je třívrstvá architektura nedostačující. Je potřeba počítat se síťovími prvky pro load balancing, s více aplikačními uzly, s databázovými replikacemi, s DNS řešením pro geografické rozdělení zátěže, s CDN pro rozdělení zátěže přidělování statického obsahu, s vrstvami pro cache aplikace a s dalšími vrstvami pro backendové či frontendové aplikace a služby. V tomto případě neexistuje žádné jasně dané a pevné řešení, každá aplikace si s sebou nese svou individuální a specifickou strategii, i když některé osvědčené postupy se využívají opakovaně. Tyto strategie nesou název vícevrstvá architektura.

\obrazek
\vlozeps{../images/wikimedia.png}{0.325}
\endobr{Webová architektura společnosti Wikimedia provozující Wikipedia.org}

Nutkno podoknout, že webové architektury využívají nejčastěji ke své komunikaci mezi klientem a architekturou protokol HTTP, který využívá portu číslo 80 a protokolu TCP pro komunikaci. Proto je celá tato odborná studie založena na práci s tímto protokolem.

\kapitola{Typy webového obsahu}
Obsah webových aplikací je rozdělen na dva typy. Obsah může být buď statického, nebo dynamického charakteru. Jak už vyplývá z obecné teorie systémů, statický obsah je konečný, transaprentní a mění se podle předepsaných pravidel, zatím co dynamický obsah se mění v závislosti na čase a jiných nepředvídatelných okolnostech. 

Pod pojmem statický obsah tedy můžeme chápat videa, obrázky a nebo statické HTML stránky. Jedná se o obsah, který se moc často nemění, nebo známe jeho přesnou životnost, a dokážeme určit, kdy přesně se má měnit. Například invalidace u statického obsahu proběhne pouze jednou za deset minut. A i když je obsah změněn uprostřed tohoto intervalu, změna se projeví až v přelomu těchto pravidelných desetiminutových intervalů, tedy až po invalidaci. Obsah je tak celých deset minut statický a neměnný.

Naopak dynamický obsah se může změnit kdykoli, nepředvídatelně, typicky na nějaký uživatelův podnět, a nebo v závislosti na čase. Příkladem může být nákupní košík v internetovém obchodě, který se mění v závislosti na uživatelově činnosti. Dále například při vložení komentáře pod určitý článek se tento komentář zobrazí ihned v seznamu komentářů. Takový obsah se pak těžko ukládá do cache paměti, dokonce je náročný i pro rozložení zátěže, poněvadž musí být zachováno uživatelovo sezení s aplikací (session).

Z uvedených vlastností vyplývá, že správa statického obsahu je jednodušší, kdežto správa dynamického obsahu je náročnější. Dynamický přístup často předpokládá propuštění požadavku až na aplikační server, který určí výsledek. Statický obsah lze jednoduše ukládat do cache paměti, protože známe jeho přesnou dobu platnosti. V této práci jsou popsány, analyzovány a testovány oba dva přístupy a je srovnán jejich přínos jak z pohledu aplikace, tak z pohledu náročnosti na vybudování.

% Aplikacni vrstva
\kapitola{Aplikační vrstva}
Aplikační vrstva představuje jádro webové architektury. Jejím účelem je příjmout a zpracovat klientův požadavek, vytvořit odpověď a tuto odpověď zaslat nazpět klientovi. Na aplikační vrstvu jsou tak kladeny úkoly celé režie procesu tvorby odpovědi, a tím pádem má velkou zoodpovědnost a mnohdy čelí i největší zátěži.

\sekce{Webová aplikační architektura MVC}
V dnešní moderní aplikační vrstvě se používá aplikační architektura návrhového vzoru MVC pro přehlednější a rychlejší způsob tvorby aplikace. Tato zkratka vychází ze slov Model, View a Controller, která označují tři základní vrstvy aplikační architektury. Tento návrhový vzor často bývá označován také jako MVC framework, který rozděluje aplikaci do tří vrstev. \cite{design-patterns}

Controller je vrstva, která vykonává akci konkrétního požadavku. Zpracovává příchozí data, parametry a atributy dané akce od uživatele, provádí jejich kontrolu a formátování. Stará se i o zabezpečení této akce. Často spolupracuje s vrstvou Model, které předává požadavky na data aplikace, a tato data dále zpracovává pro předání do vrstvy View. \cite{design-patterns}

Model má za úkol přistupovat k datovým úložištím, a to buď k perzistentní databázi, nebo souborovému systému, cache či jiným typům úložišť. Zapouzdřuje tak datovou logiku frameworku. Existují různá řešení vrstvy Model. Například ORM, neboli Object Relations Mappping, kterém jsou entity se svými atributy a vztahy mapovány podle relační databáze. Další možností je Active Record, neboli aktivní záznam tabulky, který se do databáze sám ukládá, načítá či maže. Další možností je Data Mapper, který má za úkol mapovat entitu do databáze a naopak. DAO neboli Data Access Object, Repository či Table Data Gateway nám umožňují přístup k popsaným řešením. Pro architektury pokročilých aplikací existuje i mnoho dalších návrhových vzorů a přístupů k datové vrstvě. Modelová vrstva bývá označována za nejsložitější vrstvu, a právě proto je potřeba dodržovat techniky OOP včetně návrhových vzorů pro další možnou rozšiřitelnost a přehlednost. \cite{design-patterns}

View klade důraz na prezentační úroveň, tedy na zabrazení výsledků uživateli. Zpracovává tak výsledek práce vrstvy Controller nad vrstvou Model a zobrazuje výsledek určitých operací. Často využívá některých šablonovacích přístupů. \cite{design-patterns}

\clearpage

\obrazek
\vlozeps{../images/mvc.png}{0.5}
\endobr{Návrhový vzor MVC a jeho životní cyklus}

\sekce{Optimalizace aplikační vrstvy}
\label{sec:profiler}
Optimalizace na úrovni aplikační vrstvy může být prováděna několika způsoby a přístupy. Tato činnost se týká převážně programátorů a softwarových inženýrů, kteří mají za úkol vývoj a údržbu aplikační vrstvy. K tomu, aby se daly identifikovat problematické části, které vyžadují optimalizaci, slouží tzv. profilery. Ty mají obecně za úkol vyprofilovat jednotlivé funkce, metody, procedury, dotazy a příkazy, které se v dané vrstvě, již je profiler určen, vyskytují. Dále mají za úkol určit dobu jejich trvání, počet volání, čas spuštění, závislosti a další parametry. Profilování, neboli určení kandidátů pro optimalizaci, je prvním a nejdůležitějším krokem pro optimalizaci aplikační vrstvy webové architektury. Další kroky se týkají především těchto oblastí:

\begin{itemize}
\item Výběr nejoptimálnějšího algoritmu pro danou úlohu
\item Výběr nejrychlejšího MVC frameworku
\item Vytváření cache souborů aplikace
\item Způsob překladu a vykonání zdrojových souborů
\item Přidání další vrstvy architektury - aplikační cache
\end{itemize}

\sekce{Druhy aplikačních vrstev}
Existuje celá škála různých programovacích jazyků a webových serverů pro implementaci aplikace. Každý z nich má své výhody a nevýhody, svá specifická řešení a přístupy. Zde je uveden krátký seznam těch v praxi nejpoužívanějších:

\begin{itemize}
\item Webový server Apache2 s programovacím jazykem PHP
\item Java Servlets, Java Spring Source
\item C\# s technologií .NET
\item Ruby on Rails
\item Python a Django
\item a mnohé další
\end{itemize}

\sekce{Ajax a webové služby}
Ajax, neboli Asynchronous JavaScript and XML, se dnes stává nedílnou součástí vývoje webových aplikací. Aplikace tak dostávájí interaktivnější charakter a obejdou se bez nutnosti znovuzaslání celého požadavku webové aplikaci. Celý tento přístup probíhá nejvíce na straně klienta. Je použit JavaScript pro programovou implementaci, který má přístup ke stromu objektů dokumentu zvaného DOM, neboli Document Object Model. V této kapitole je AJAX uveden z toho důvodu, že používá objekt XMLHttpRequest pro komunikaci s aplikačním serverem. Tyto aplikační požadavky jsou nazývány webovými službami pro Ajax. Tyto požadavky jsou vykonávány na aplikační vrstvě a představují potenciální zátěž, která musí být v některých případech optimalizována.\cite{ajax}



% Databaze
\kapitola{Dabázová vrstva}
\label{sec:database}
Úkolem databázové vrstvy ve webové architektuře je zajišťovat datové služby a uchovávat tak aplikační data perzistentní. V oblasti webových architektur se nejčastěji vyskytují relační databázové systémy, a proto je tato práce soustředěna na tento typ databázových systémů. Databázový systém obecně tvoří databáze, tedy skupiny strukturovaných homogenních souborů, a SŘBD, neboli systém řízení báze dat, jakožto integrovaný softwarový prostředek řídící bázi dat.

\sekce{Optimalizace SQL dotazů}
Optimalizace dotazů SQL je nedílnou součásti procesu práce s databázovým systém v prostředí vysoké zátěže. Je totiž důležité nejenom umět si získat potřebná data, ale je potřeba zvážit i za jakou cenu tato data prostřednictvím databázavého systému získáváme. Hovoříme-li o webových architekturách s vysokou zátěží, je tento proces optimalizace velice důležitý. Každá operace, každý dotaz, každá akce potřebuje ke své realizaci určité hardwarové a systémové prostředky. V prostředí vysoké zátěže je důležité ušetřit těchto prostředků co nejvíce.

K tomu, abychom mohli vůbec přistoupit k optimalizaci SQL dotazů, je potřeba určit a identifikovat, které tyto dotazy jsou opravdu náročné na prostředky a čas, neboli mají vysokou cenu. K tomu slouží tzv profilery (viz. kapitola \ref{sec:profiler}). Profilery mohou být určeny pro aplikační vrstvu, kde profilují nejenom zdrojové kódy aplikace, ale samozřejmě i databázové dotazy, které jsou z této aplikační úrovně spuštěny. Tímto způsobem je možné získat přehled všech operací, které probíhají na aplikační i databázové vrstvě, poněvadž tyto vrstvy spolu úzce souvisí a spolupracují. Další možností je použít profiler určený přímo pro databázovou vrstvu. Takový profiler pak profiluje pouze databázovou vrstvu, jednotlivé databázové dotazy, jejich cenu, dobu trvání, a jiné další statistiky.

Každý SQL dotaz má nějaký svůj exekuční plán. Databázový systém po obdržení SQL dotazu vybírá z několika možných exekučních plánů ten nejvýhodnější, který je po té v databázi proveden. Při výběru exekučního plánu je brán v potaz výběr indexu a způsob skenu tabulek, vybraná spojení, aj. Exukuční plán je možné zobrazovat v mnoha databázových systémech pomocí SQL dotazu EXPLAIN, a identifikovat tak místa exekučního plánu, která mohou být kandidátem pro optimalizaci.\cite{optimalizace-sql}

Pro optimalizaci SQL dotazů je možné určit několik základních oblastí, na které se lze zaměřit při konkrétní optimalizaci určitého SQL dotazu:

\begin{itemize}
\item Normalizovaný databázový návrh
\item Vnořené SQL dotazy
\item Indexace, výběr indexu a způsob prohledávání
\item Výběr druhu a pořadí spojení
\item Způsob používání podmínek, klauzulí a operátorů
\end{itemize}

\sekce{Indexace}
Indexace je důležitá a nejefektivnější optimalizace dotazů SQL. Při průchodu dat tabulkou má databáze na výběr několik možností prohledání. První možností je prohledat všechny řádky tabulky podle SQL podmínek. To je nazýváno obecně Full Table Scan, nebo také Sequence Scan, neboli sekvenční prohledávání. Další možností je pužití některého z indexů pro přístup k hodnotám namapovaných na jejich ROWID, které ukazuje na fyzické uložení. Toto prohledání bývá nazýváno Index Range Scan, nebo jen obecně Index Scan, neboli indexační prohledávání. Samozřejmě prohledávání tabulek pomocí indexace je výrazně rychlejší, a tím pádem důležité pro opimalizaci SQL. \cite{optimalizace-sql}

Indexy jsou fyzicky i logicky uloženy v asociativních tabulkách, a díky tomu i odděleny od datových tabulek. Čili při smazání indexů se datové tabulky nesmažou ani nijak nezmění. Pouze se může zpomalit přístup k datům, který byl rychlejší díky těmto indexům. Tabulky s indexy jsou samozřejmě uloženy na disku, poněvadž jejich velikost je obrovská a nevešly by se do operační paměti RAM, i když přístup k ní je daleko rychlejší. Proto je potřeba volit nějaký vhodný algoritmus prohledání a přístupu k indexům uloženým na disku. Od zvoleného algoritmu se odvyjí i název a druh používaných indexů. V každém databázovém systému samozřejmě naleznete některé typické a některé atypické druhy indexů. \cite{optimalizace-sql} Zde je krátký výběr možných indexů:

\begin{itemize}
\item B-tree - pro přístup pomocí Root-Node-List
\item Bitmap - pro výčtové sloupce
\item R-tree - typ indexu optimalizovaný pro geometrická data.
\item GiST - zobecněný vyhledávací strom
\item a další
\end{itemize}


\sekce{Partitioning}
Partitioning, který je občas do češtiny překládán jako segmentace, případně jako škálování, slouží v relačních databázových systémech k rozdělování tabulek a indexů do menších částí a komponent. Díky tomu je pak činnost databáze rychlejší a snazší. Při této segmentaci tak může dojít k rozdělení tabulek na více pevných disků či serverů. Tyto segmenty jsou na sobě nezávisle, ale přitom je k nim možné přistupovat přes tabulku, pro kterou byla segmentace vytvořena. Databázová tabulka a její vlastnosti, jako například referenční integrita nebo žádná redundance, jsou stále zachovány a fungují přes všechny její segmenty. Dokonce i když dojde k selhání či výpadku jednoho ze segmentů, ostatní jsou stále přístupné a je možné s nimi pracovat. Partitioning je možné provádět na několika úrovních a podle různých klíčů. U segmentovaných tabulek je důležité rozmyslet si jakou strategii zvolit. 

Při vertikální segmentaci dojde k segmentaci podle definovaných sloupců databázové tabulky. Klíčem při tomto rozdělení je určení sloupečků, které se nepoužívají ve where klauzuli, nebo jsou prázdné či zřídka používané. 

Častěji používáným přístupem je horizontální segmentace tabulek, čili segmentace podle řádků. Zde se segmentují řádky, podle určité hodnoty databázového sloupce. O tom, do jakého segmentu bude řádek tabulky vložen, rozhoduje určitý interval, hodnota výčtu nebo konkrétní funkce.

Další možnost je aplikační úroveň segmentace, která se zřídka objevuje v souvislosti s Partitioning. Nejedná se totiž o segmentaci určité databázové tabulky, ale o segmentaci databáze. Část tabulek je umístěna na jednom serveru, část na dalším serveru, a tak dále.

Partitioning je důležitým nástrojem při optimalizaci databázové vrstvy v architektuře webových systémů v prostředí vysoké zátěže. Dá se totiž předpokládat, že se zvětšující se zátěží roste i počet záznamů tabulek, a tak se doba přístupu zvětšuje a prostředky se zatěžují ještě víc. Tyto problémy dokáže vyřešit partitiong.
\cite{partitioning-db}

\sekce{Replikace}
Replikací rozumíme technologii, která umožňuje nasadit více databázových serverů v rámci jedné databáze. Jedná se tak o sdílení dat mezi více hardwarovými, softwarovými a jinými prostředky a jejich přenositelnost. Účelem replikace je dosáhnout vysoké dostupnosti databázového systému a škálování výkonu pro optimalizaci v prostředí vysoké zátěže. Obecně existují dvě základní varianty databázových replikací, od kterých se odvyjí jejich další využití. Samozřejmě v závislosti na konkrétním databázovém systému pak existují další členění a nastavení. 

Replikace varianty master-slave je podporována ve většině databázových systémů. Jedná se o jednodušší tzv. jednosměrnou replikaci. V této variantě je určen autonomní prvek, jedna replikace, která akceptuje a zpracovává požadavky na změny. Takováto replikace nese název master. Prvek s názvem slave je věrnou kopií autonomního prvku master. Slouží pouze ke čtení a může jich existovat více pro jeden master. Jakmile master obdrží a zpracuje požadavek na změnu, tak jej po dokončení přenese na ostatní slave replikace.

Replikace typu master-master bývá označována jako obousměrná. To znamená, že jsou v rámci jednoho databázového systému minimálně dvě replikace typu master, které akceptují všechny druhy požadavků na změny i čtení a přenáší je vzájemně mezi sebou. Z této vlastnosti vyplývá, že může dojít ke kolizím, například pokud dvě replikace master zapisují do stejné tabulky. Takové kolize jsou nevyhnutelné a je potřeba umět je řešit.

Způsob přenosu mezi jednotlivými replikacemi může být synchronní či asynchronní. U synchronního přenosu se čeká až se změny provedou na všech ostatních replikacích. Tento proces je časově náročný, ovšem na druhou stranu je celý databázový systém konzistentní jako celek. U asynchronního přenosu se nečeká na dokončení přenosu mezi ostatními replikacemi. Díky tomu je celý databázový systém rychlejší, ovšem může dojít k nekonzistenci, kdy na ostatní replikace ještě nejsou přenesena všechna data.

Administrace, nástroje a konfigurace replikací jsou zabudované v téměř každém databázovém systému. Je důležité poznamenat, že tyto nástroje nejsou mnohdy dostačující řešení pro architektury v prostředí vysoké zátěže, a je proto nutné používání jiných doplňkových nástrojů. Také je více než důležité říct, že v prostředí vysoké zátěže se webová architektura bez databázových replikací jen těžko obejde.\cite{replikace}

\sekce{Druhy relačních databází}
V dnešní době existuje několik druhů relačních databázových systémů. Každý z nich má své klady a zápory, ovšem princip a způsob práce těchto databází je v základu podobný. Zde je uveden přehled těch v praxi nejběžnějších:

\begin{itemize}
\item Oracle
\item MySQL
\item PostgreSQL
\item MSSQL
\item Firebird
\item a mnoho dalších
\end{itemize}



% Web cache
\kapitola{Webové cache}
Webové cache jsou důležitou vrstvou pro rozšíření výchozí třívrstvé architektury. Jak už vyplývá z názvu cache, jedná se o vyrovnávací paměť, jejíž hlavní účel je zrychlit odpověď webové aplikace na požadavek klienta. Zároveň je důležité poznamenat, že nefunkčnost, zánik či pád cache vrstvy nesmí nijak ovlivnit chod apikace, která musí být funkční i nadále. Účel této vrstvy je pouze zrychlit přístup k datům či již jednou interpretovaných odpovědím webové aplikace.

Webová cache se nachází mezi klientem a aplikační vrstvou. Základní komunikace probíhá tak, že klient pošle HTTP požadavek, aplikační server ho přijme a navrátí HTTP odpověď. Při existenci cache vrstvy probíhá komunikace jiným způsobem. Klient pošle HTTP požadavek a webová architektura zjistí, zda-li je tento HTTP požadavek určen pro ukládání do cache paměti. Pokud ano, tak webová architektura zkusí získat odpověď z cache paměti. Když tuto odpověď v paměti nalezne, zašle ji přímo klientovi. V opačném případě je požadavek poslán do aplikační vrstvy architektury, která jej zpracuje, vytvoří odpověď kterou uloží do cache paměti a pošle klientovi. Při příštím stejném požadavku bude odpověď vrácena z paměti cache. Dojde-li ke změně dat, která jsou uložena v cache paměti, dojde k invalidaci uložených dat v cache paměti a celý proces začne od začátku s novým HTTP požadavkem.

Pro webové architektury v prostředí vysoké zátěže je tato vrstva nevyhnutelná. Odpovědi z cache vrstvy jsou daleko rychlejší, dokonce až mnohonásobně, než odpovědi z aplikační vrstvy. Tato práce se zabývá různými druhy cache, výsledky jejich profilování a jejich testováním v prostředí vysoké zátěže.

\obrazek
\vlozeps{../images/cache-process.png}{0.6}
\endobr{Diagram aktivit cache webových systémů}

\sekce{HTTP hlavičky pro ovládání cache}
\label{sec:http-headers}
Komunikace ve webových aplikacích probíhá ve valné většině případů na úrovni protokolu HTTP. Každý HTTP požadavek obsahuje HTTP hlavičky, kterými určuje požadavek, klienta a obsahuje časové razítko. Odpověď na tento požadavek navrací v hlavičkách návratový kód, informace o serveru, časové razítko, typ obsahu odpovědi, délku odpovědi a informace pro případné ukládání do cache paměti. Právě jednotlivé cache hlavičky jsou důležité pro nastavení, ukládání a invalidace do proxy cache paměti nebo do reverzní proxy cache paměti.

Existují dva základní modely pro určení práce s cache vrstvou. Prvním je expirační model. Tento model určuje, do kdy je platná HTTP odpověď, neboli do kdy může tuto odpověď cache vrstva ukládat a označovat ji jako platnou a stále čerstvou. Tento model může být realizován dvěma způsoby. Prvním je hlavička Expires s časovým razítkem určující, do kdy je odpověď platná. Druhým, novějším a daleko flexibilnější a konfigurovatelnější způsobem je použití Cache-Control. Díky tomuto způsobu je možné určit další parametry, nejenom to, do kdy je daná HTTP odpověď platná. Díky Cache-Control je možné určit, zda-li je odpověď určena jen pro sdílené cache (proxy cache), nebo jen pro uživatelské prohlížečové cache, nebo zda-li ji ukládat či nikoli, atd.\cite{rfc-http}

Druhým modelem je model validační. Ten určuje způsob komunikace pro zjištění, zda-li je odpověď uložená v cache paměti stále validní. Základem je, že cache, která má uloženu odpověď se zeptá, je-li odpověď stále validní a server odpoví jestli ano či vrátí novou čerstvou odpověď. Tento proces lze realizovat opět dvěma způsoby. Tím prvním je určení tzv. Last-Modified. Při prvním požadavku cache získá odpověď s touto hlavičkoku. Odpověď si uloží a při dalším požadavku se cache vrstva dotáže serveru pomocí hlavičky If-Modified-Since s časovým razítkem, zda-li je odpověď stále validní. Server odpoví návratovým kódem 304, který říká, že nedošlo k žádné změně od daného časového razítka, a nebo vrátí novou čerstvou odpověď, pokud došlo ke změně. Na podobném principu je založena i hlavička Etag neboli Entity tag. Etag je unikátní identifikátor vygenerovaný serverem pro danou HTTP odpověď. Cache vrstva si při prvním požadavku uloží odpověď s tímto Etag. Při dalším požadavku pošle na server HTTP požadavek s hlavičkou If-None-Match s tímto Etag. Pokud se hodnoty Etag shodují, vrátí aplikační server odpověď s návratovým kódem 304, a nebo celou čerstvou odpověď.\cite{rfc-http}

Ovládání pomocí HTTP hlaviček slouží hlavně k statickému obsahu. Pro tento účel je pak dobré zvážit jestli je lepší odpovědi měnit v nějakých časových intervalech a používat tak expirační model, či jestli se vyplatí nasazovat model validační, který s sebou nese složitější administraci.\\
\clearpage
Příklad HTTP hlaviček pro HTTP odpověď:
\begin{scriptsize}
\begin{verbatim}
HTTP/1.1 200 OK
Date: Mon, 23 May 2005 22:38:34 GMT
Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)
Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
Etag: "3f80f-1b6-3e1cb03b"
Accept-Ranges:  none
Content-Length: 438
Connection: close
Content-Type: text/html; charset=UTF-8
\end{verbatim}
\end{scriptsize}

\sekce{Druhy cache}
Ve webových architekturách existuje několik druhů cache vrstev. Jejich členění se odvyjí od jejich účelu, pozici v architektuře a typu ukládaných dat. Tyto atributy mezi sebou úzce souvisí. Základním členěním může být jejich pozice z pohledu internetu, a to dělení na klientskou a serverovou část. Za klientskou část považujeme cache systém uživatelova prohlížeče či systémovější proxy cache. Na straně serveru se vyskytují reverse proxy cache či aplikační distribuované cache.

\obrazek
\vlozeps{../images/cache-types.png}{0.5}
\endobr{Druhy cache ve webové architektuře}

\podsekce{Proxy cache a cache prohlížeče}
Tyto druhy cache se týkají klientské části webové architektury, neboli části před internetem. Znamená to tedy, že odpověď na klientův požadavek je vrácena z cache paměti lokální sítě, a tento požadavek vůbec nevstoupí do sítě internet na vzdálený dotazovaný server. Tyto cache vrstvy zde nejsou jen pro to, aby zrychlily odevzvu na požadavek, ale také aby zmenšily odchozí komunikaci z lokální sítě. A to z toho důvodu, aby byla šířka pásma přístupná i jiným službám a ušetřily se prostředky na odchozí komunikaci.

V dnešních moderních prohlížečích je práce s cache pamětí podporována. Cache prohlížeče může nastavovat, konfigurovat, či vymazat pouze uživatel, neboli klient sám. Tato paměť ukládá hlavně statický obsah, například obrázky, CSS soubory či JS soubory. Cache paměť najde své uplatnění, například když jsou uživatelovy požadavky směřovány jedné webové aplikaci se stejným vzhledem, rozhranním nebo částí funkcionalit. Takováto data mohou být ukládána do cache paměti na dlouhou dobu, a proto musí aplikace dbát na to, aby byla tato data z cache promazávána tak, jak je opravdu potřeba. Jednou z možností je určit jinou url adresu pro stejný soubor pomocí tzv. Query string, například takto:

\begin{scriptsize}
\begin{verbatim}
<link rel="stylesheet" type="text/css" href="style.css?QUERY_STRING" media="all" />
\end{verbatim}
\end{scriptsize}

Proxy cache bývají budovány a instalovány providery a poskytovateli připojení k internetu. Jejich záměr je jednoduchý. Jde o to snížit míru odchozí komunikace, nezatěžovat tolik šířku pásma a zmenšit náklady spojené s touto komunikací. Nejběžnějším nastavením těchto proxy cache pamětí bývá ukládání a invalidace obsahu v závislosti na HTTP hlavičkách přijaté odpovědi. Nainstalujeme-li například takovouto cache ve firmě či na nějakém sídlišti s několika desítkami, stovkami, či dokonce tisíci uživateli, je možné, že část z nich má každé ráno stejný požadavek na stejný zpravodajský server, tudíž mají i stejnou odpověď. A tak může být první odpověď uložena do cache paměti a dalším uživatelům může být servírována z proxy cache paměti.\cite{proxy-cache}

\obrazek
\vlozeps{../images/proxy-cache.png}{0.5}
\endobr{Proxy cache ve webové architektuře}

\podsekce{Reverzní proxy cache}
\label{sec:reverse-proxy}
Reverzní proxy cache, někdy označovány jako tzv. Gateway cache, mají podobný systém činnosti jako proxy cache. Mají za úkol ukládat statický obsah ve formě HTTP odpovědí a tyto odpovědi vracet nazpět tam, odkud přišel jejich požadavek. Úkolem je tak pokud možno nepropustit požadavek dále na aplikační vrstvu, stejně jako úkolem proxy cache je pokud možno nepropouštět požadavek dále do internetu. Rozdíl mezi reverzní proxy cache a proxy cache spočívá v jejich pozici ve webové architektuře, a také v tom, kým jsou instalovány. Pozice reverzní proxy cache je na straně serveru, neboli blíže aplikační vrstvě architektury, tedy na druhé straně internetu, než odkud příchází požadavky klientů a kde jsou instalovány proxy cache. Reverzní proxy cache jsou instalovány samotnými administrátory a programátory webové aplikace. Jejich účel tkví v zajištění rychlejší odezvy webové aplikace na HTTP požadavky klientů. Reverzní proxy cache jsou nedílnou součástí webové architektury v prostředí vysoké zátěže a bez jejich existence by jen těžko mohla být webová aplikace spolehlivá a rychlá.\cite{proxy-cache}

\obrazek
\vlozeps{../images/reverse-proxy-cache.png}{0.5}
\endobr{Reverzní proxy cache ve webové architektuře}

\podsekce{Aplikační distribuovaná cache}
Doposud byly popisovány cache paměti pro ukládání statického obsahu. Ovšem v praxi se od projektového vedení setkáme s požadavky na dynamické chování aplikace. Jako příklad může posloužit opět situace s komentáři, kdy jeden uživatel vloží komentář k některému z článků. Tento komentář se musí okamžitě objevit v seznamu komentářů k článku. V případě statického obsahu, který se mění pouze v určitých intervalech, může uživatel nabýt dojmu, že se jeho komentář nepodařilo vložit a zkusí ho vložit znovu. Takové chování aplikace určitě není v souladu s dobrým chováním interakce mezi uživatelem a aplikací. K tomu, aby se dala data ukládat do cache a aplikace byla stále dynamická, slouží tzv. aplikační distribuovaná cache. HTTP požadavek je rozdistribuován mezi menší požadavky a mezi cache paměti.

Jak už vyplývá z názvu této cache, o manipulaci s touto cache pamětí se stará aplikační vrstva. Standardně se ukládají do cache paměti ta data, k nimž je dlouhá doba přístupu, obvykle data z databáze. Účelem je tedy ušetřit spojení a dotazy na databází. Jeden HTTP požadavek s konkrétní url je často rozdělen na několik požadavků do databáze, v závislosti na tom, o jaká data se jedná. Například v rámci jedné HTTP stránky může být databáze dotázána o požadovaný článek a seznam komentářů pod článkem. Databáze tak obdrží dva SQL dotazy, na které vrátí příslušná data z databáze. Aby se příště aplikace nemusela na tato data dotazovat, uloží si je do aplikační cache paměti.

Při ukládání takových dat do cache paměti aplikační vrstva určuje, jak a kam mají být data uložena, a kdy a za jakých podmínek mají být invalidována. Při aplikaci této cache vrsty dochází k propuštění požadavku na aplikační servery, což znamená větší zátěž aplikační vrstvy. Reverzní proxy cache jsou v tomto směru nepoužitelné, slouží pouze pro statický obsah a všechny požadavky propouští dále na aplikační vrstvu.

Při práci s aplikační distribuovanou cache je důležité si uvědomit několik základních pravidel. Prvním pravidlem je ukládat data do cache paměti co nejmenší. Účelem je distribuovat jednotlivá data v různých kontextech. Dále je důležité ukládat data znovuzkonstruovatelná. Je důležité umět z cache paměti přečíst to, co do ní bylo uloženo. Nejlepší je ukládat data serializovaná. Dále je nutno dodržet jednoznačný a jasně definovaný klíč či jmenný prostor pro tato data. Aplikace totiž musí vědět, kde a jak se ptát na data. Dalším pravidlem je pečlivá a kompletní invalidace dat v cache paměti. Právě invalidace je největší problém pro práci s cache pamětí. Stejná data mohou být interpretována v různém kontextu. Například při vložení nového článku se změní data pro seznam všech nejnovějších článků, a také data pro seznam nejnovějších článků v dané rubrice. Vzhledem k tomu, že aplikace implementuje dynamické chování, musí být tento článek vidět ihned po vložení ve všech zmíněných interpretacích. Čili musí dojít k invalidaci všech závislostí. Tento problém je označován jako invalidační kaskády, a proto je důležité konstruovat aplikaci tak, aby se těmto kaskádám vyhýbala co nejvíce nebo s nimi musí vývojář aplikace počítat už pří návrhu aplikační distribuované cache vrstvy.

\obrazek
\vlozeps{../images/application-distributed-cache.png}{0.5}
\endobr{Aplikační distribuovaná cache ve webové architektuře}


\kapitola{CDN}
Vrstva CDN neboli Content Delivery Network je důležitou součástí webové architektury v prostředí vysoké zátěže. Jejím úkolem je rozdělit zátěž webové architektury mezi více uzlů. Jedná se o několik serverů, které mají za úkol klientům předávat vesměs statický obsah ve formě multimédií, stream videa či softwarových aktualizací. 

CDN mají obvykle jeden centrální prvek, který rozhoduje o tom, na který z CDN uzlů se požadavek přesměruje. Rozhodování může probíhat v závislosti na spoustě ukazatelů a záleží už na konkrétním využití CDN. Centrální prvky se mohou rozhodovat například na základě geografického rozdělení. Centrálním prvkem je DNS server, který má přehled o kompletní topologii sítě CDN. Díky tomu má přehled o tom, který ze serverů se kde nachází. Dalším ukazatelem pro centrální prvek může být stav serverů, jejich vytížení operační paměti RAM a procesoru CPU, stav odesílaných paketů na síťových kartách, stav cache pamětí apod. 

Existují komerční i open source CDN sítě, větší společnosti pak mívají vlastní řešení. Mezi CDN se objevují i možnosti pro servírování dynamického obsahu, ovšem primární účel by měl být obsah statický. CDN najdou významné uplatnění tam, kde dochází k přenosům velkých souborů, které se už nijak nemění, a nebo se mění ve velkých intervalech.\cite{cdn}

\obrazek
\vlozeps{../images/cdn.png}{0.5}
\endobr{Ukázka komunikace klienta s CDN sítí}


% Virtualizace
\kapitola{Virtualizace}
Virtualizace je moderní pojem, který umožňuje lepší škálovatelnost aplikace a možnost práce s jednotlivými vrstvami webové aplikace a jejími servery. V dnešní době se nejvíce hovoří o tzv. virtualizaci platforem, což znamená provozování více virtuálních počítačů s vlastním operačním systémem na jednom fyzickém počítači. Takto virtualizované počítače včetně operačních systémů a aplikací jsou od sebe navzájem izolovány. 

Příklady profesionálních nástrojů pro virtualizaci počítačů jsou VMWare, Hyper-V a nebo třeba Citrix Xen Server. Základem virtualizace je fyzický server, který je pod správou vrstvy hypervizor, která řídí přístup k fyzickým zdrojům a rozhraním. Takto přípravený fyzický server se nazývá host. Několik hostů může být spravováno v jedné skupině nazývané cluster, která má své zdroje. To vše je obvykle spravováno centralním serverem pomocí desktopového klienta či webového rozhraní.

Virtualizace přínáší spoustu výhod. Jednou z nich je elastičnost zdrojů. Jakmile se totiž některý z virtualizovaných serverů jeví jako velice vytížený, je možné mu během pár vteřin přidat chybějící prostředky. Stejně tak je možné tyto prostředky ubrat u serverů, které jej nevyužijí.

Pro webové architektury je tou největší výhodou konsolidace serverů, neboli provozování většího počtu virtualizovaných serverů na menším počtu serveru fyzických. Tohoto řešení se hodně využívá ve webových architekturách. Vzhledem k náročnosti jednotlivých vrstev webové architektury se v dnešních dnech používá přístupu s více virtualizovanými servery, které mají mnohdy jediný účel. Například jeden server pro datábázi, další pro webový server, mailový server, cache servery, apod.

Další výhodou může být redukce hardware, el. energie, prostoru a dalších zdrojů. Bez virtualizace by přidání dalšího fyzického serveru znamenalo nakoupení HW komponent, vytvoření dalšího místa v serverovně a přivedení dalšího zdroje elektrické energie. Pro virtualizaci nového serveru stačí vyhodnotit stávající využití fyzických prostředků jinými virtuálními servery, dále zhodnotit rezervy na fyzických serverech, popřípadě dokoupit už jen dílčí komponenty jako například operační paměť RAM.

Obrovskou výhodou virtualizace je možnost sjednocení vývojového, testovacího a produkčního prostředí. Díky virtualizaci získáme během pár okamžiků věrnou kopii některého ze serverů. Stejně tak je možné virtuální server velice rychle přenést na jiný fyzický server. Dokonce se může tento přenos obejít i bez výpadku serveru, pokud jsou ve stejném clusteru.

Virtualizace dnes znamená obrovské ulehčení pro administraci jednotlivých serverů, jejich konfiguraci, rozšiřitelnost, apod. Dokonce právě vznikající trend s názvem Cloud Computing vychází z virtualizace, hlavně z jejích modernějších oblastí. Proto je pro webovou architekturu v prostředí vysoké zátěže důležité virtualizovat její jednotlivé vrstvy a servery.\cite{virtual}

\clearpage

\obrazek
\vlozeps{../images/virtual.png}{1}
\endobr{Ukázka virtualizovaných systémů v prostředí na jednom fyzickém serveru}


% Load balancing
\kapitola{Rozložení zátěže}
\label{sec:load-balancing}
Rozložení zátěže, neboli load balancing, se používá v momentě, kdy zátěž webové architektury přeroste možnosti a výkonnost některého ze svých serverů. Tím pádem je nutné přidat další server, a zajistit tak rovnoměrné rozložení zátěže mezi tyto servery. 

Nejznámějším způsobem rozložení zátěže je tzv. Round Robin DNS. Při dotazu klienta na IP adresu cílového serveru, vrátí DNS server náhodný záznam jednoho z několika cílových serverů. Tímto způsobem je zátěž rozdělena náhodně, čili zhruba rovnoměrně mezi všechny servery. Zde nastává problém se sezením mezi aplikací a klientem, tzv. session. Pokud se klient připojuje k různým serverům zcela náhodně, tak není zaručeno, že bude mít vždy stejné sezení s aplikací. Je totiž důležité, aby když se například uživatel přihlásí do aplikace, došlo k uložení informace o přihlášení do jeho sezení a při zobrazení příští stránky se po něm aplikace nevyžadovala opětovné přihlášení. V takovém případě náhodného přidělování koncových serverů je potřeba ukládat tato sezení do společného úložiště pro všechny koncové uzly.

Další možnost je řešit rozložení zátěže na úrovní transportní vrstvy. K tomu slouží HW load balancery, které rozhodují, na který ze serverů se požadavek přepošle dál. Tato profesionální zařízení se už mohou rozhodnout v závislosti na jiných parametrech jako aktuální počet dotazů, přenášených dat, vytíženosti šířky pásma, zdrojové IP adresy, její geografické polohy, apod. 

Existují i aplikační load balancery. Ty najdou své uplatnění ve webových architekturách. Jedná se o server s běžícím softwarovým load balancerem, který přijme a zpracuje požadavek a rozhodne, kterému z koncových serverů ho předá dál. Aplikační load balancer by proto neměl mít problém zajistit klientovi vždy stejný koncový server.

Ve webových architekturách v prostředí vysoké zátěže je zcela nevyhnutelné použití více uzlů, například více aplikačních serverů. Vrstva pro rozložení zátěže je tak nedílnou součástí webové architektury v prostředí vysoké zátěže.

\obrazek
\vlozeps{../images/load-balancing.png}{0.5}
\endobr{Ukázka jednoduchého rozložení zátěže}


% Dalsi vrstvy
\kapitola{Další vrstvy aplikace}
V prostředí vysoké zátěže je velice důležitá škálovatelnost. Ta vzniká přidáváním dalších samostatných vrstev, čímž se ubírá práce jiným vrstvám. Proto je dobré zaměřit se i na další vrstvy, další aplikace, služby a možnosti, které mohou běžet samostatně bez nutnosti režie a zásahu jiných vrstev, a přítom mohou hodně odlehčit dalším vrstvám.

Jednu z možností, jak přidat další vrstvy aplikace a odlehčit tak jiným vrstvám, jsou No SQL databáze. Jak už bylo nastíněho v kapitole \ref{sec:database}, jedním z největších zdrojů zpoždění ve webových architekturách v prostředí vysoké zátěže mohou být databáze. Proto je vhodné kombinovat toto primární úložiště i s jinými možnostmi. No SQL databáze jsou od klasických relačních databázi odlišné tím, že nemají žádnou referenční integritu, pevnou strukturu záznamů, nezabraňují redundanci, používají jiný jazyk pro dotazování a jsou volnější a flexibilnější. Své uplatnění naleznou u dat, ve kterých není potřeba uchovávat pevnější logiku a se kterými není potřeba provádět složitější operace. Mohou se hodit i k uchovávání dat k některým statistikám pro analýzy v Business Inteligence.

Většina webových aplikací podporuje funkci vyhledávání. Ať už se jedná o kompletní prohledávání všech dat aplikace či pouze o našeptávač, tak je zbytečné těmito akcemi zahlcovat databázový čas a prostředky. Existují totiž i jiné možnosti, jiné aplikace, které zastávají funkčnost vyhledávání. Těmto aplikacím či službám se předávají data k prohledávání, které si samy prohledávají, indexují a vytváří další statistiky pro vyhledávání a nezatěžují tím aplikační či databázovou vrstvu.

Určitě existuje celá řada dalších aplikací a služeb, které pomohou většímu rozdělení a škálování aplikace na jiné další části, které dokážou fungovat nezávisle na sobě. Nejdůležitější je co nejvíce odlehčovat vrstvám webové architektury v prostředí vysoké zátěže.



% Prakticka cast
\kapitola{Praktická část s experimenty a výsledky}
Praktická část je zaměřena na testy a optimalizaci jednotlivých vrstev webové architektury v prostředí vysoké zátěže. V této práci jsou rozebrány jednotlivé vrstvy architektury, se kterými byly provedeny testy a experimenty. Jedná se o aplikační vrstvu, databázovou vrstvu, reverzní proxy cache vrstvu a aplikační distribuovanou cache vrstvu. Součástí práce nejsou pouze popis a charakteristika jendotlivých kroků optimalizace, ale i jejich výsledné statistiky a zátěžové testy. Hlavní částí praktické části je ovšem návrh a implementace aplikační úrovně plně podporující práci s aplikační distribuovanou cache. Dále je popsána i výsledná konfigurace a nastavení jednotlivých vrstev architektury. Výsledkem je tedy kompletní použitelná studie řešící problematiku webové architektury v prostředí vysoké zátěže.

% Popis aplikace a nastroju
\sekce{Vrstvy webové architektury}
Webová architektura sestává z klientské vrstvy, reverzní proxy cache vrsrtvy, aplikační vrstvy, aplikační distribuované cache a databázové vrstvy. Klientská část je tvořena jedním uživatelem s operačním systémem Linux Ubuntu a zátěžovým testovacím nástrojem Siege. Reverzní proxy cache vrstva je realizována programem Nginx. Aplikační vrstva se skládá z webového serveru Apache2 s programovacím jazykem PHP a s profilovacím nástrojem XHProf. Aplikační distribuovaná cache vrstva je tvořena programem Memcached. Databází je PostgreSQL. Všechny tyto vrstvy serverové části webové architektury jsou vytvořeny na zvláštních virtualizovaných serverech. Pro reverzní proxy cache a aplikační distribuovanou cache byl zvolen jeden server. Každý ze serverů je virtualizován za pomoci virtualizačního nástroje VirtualBox. Celá webová architektura je konfigurována v jedné virtuální lokální síti 10.9.0.0/24 se statickým přidělením IP adres. Rozhraní pro přípojení těchto virtualizovaných serverů do virtuální sítě je realizováno pomocí síťových mostů. Vzhledem k tomu, aby bylo možno ukázat velké poměrové rozdíly v jednotlivých krocích optimalizace pro jednotlivé vrstvy architektury, bylo roznodnuto pro velice slabé hardwarové vybavení jednotlivých serverů. Tyto servery mají 512MB operační paměti RAM a jeden jednojádrový procesor s frekvencí 2GHz.

\obrazek
\vlozeps{../images/nginx-architecture.png}{0.5}
\endobr{Vrstvy implementované webové architektury}

\sekce{Testovací a profilovací nástroje}
Proto, aby mohla být všechna tvrzení a závěry řádně podložena, a aby bylo možné identifikovat místa nutná pro optimalizaci, jsou potřeba určité testovací a profilovací nátroje. Pomocí profilovacího nástroje XHProf byly vyprofilovány statistiky pro aplikační vrstvu. Byl proveden rozbor exekučních plánů pro SQL dotazy pro databázovou vrstvu, aby byla vidět míra jejich optimalizace. Také bylo potřeba vytvořit prostředí vysoké zátěže a k tomu dopomohl program Siege.

\podsekce{XHProf}
K tomu, aby bylo možné profilovat programovací jazyk PHP, byl vybrán profilovací nástroj XHProf. Tento nástroj byl vyvinut v programovacím jazyce C. Uvolněn byl pod open-source licencí Apache 2.0. Autorem tohoto profilovacího nástroje je společnost Facebook. Tento profilovací nástroj dokáže vyprofilovat nejenom dobu trvání jednotlivých metod a funkcí, ale i jejich procesorové či paměťové nároky. XHProf je možné provozovat na operačních systémech Linux, FreeBSD a Mac OS X.

Jeho instalace a konfigurace je jednoduchá a bezproblémová. Stačí si stáhnout instalační balíček s rozšířením, zkomipilovat a nainstalovat. Po instalaci je nutné jej zaregistrovat jako rozšíření pro PHP v konfiguračním souboru php.ini. Samotné použití je pak velice snadné. Na začátek PHP skriptu se přidá zdrojový kód s jeho aktivací a na konci PHP skriptu kód pro jeho deaktivaci.

Výsledkem profilování je přehledná statistika jednotlivých metod a funkcí ve formátu HTML. Všechno v přehledné tabulce, ve které je možné měnit pohled výsledků profilování podle specifické metody či funkce. V tabulce je možné pozorovat čas strávený vykonáváním pouze dané funkce, čas strávený vykonáváním funkcí z ní volané, počet volání funkce, doba trvání, procesorový čas a paměťové nároky. Výsledkem může být i graf vygenerovaný ze statistik profilování a ze závislostí mezi voláním jednotlivých funkcí.

Tento program je nenáročný a může být provozován i v ostrém provozu. Výsledky takového profilování jsou důležité k identifikaci problémových míst k optimalizaci, čili pro webovou architekturu v prostředí vysoké zátěže jsou nevyhnutelné.\cite{xhprof}

\newpage
Příklad použití XHProf profilování:
\begin{scriptsize}
\begin{verbatim}
<?php
// Enable profiling
if (extension_loaded('xhprof')) {
    include_once '/usr/local/lib/php/xhprof_lib/utils/xhprof_lib.php';
    include_once '/usr/local/lib/php/xhprof_lib/utils/xhprof_runs.php';
    xhprof_enable(XHPROF_FLAGS_CPU + XHPROF_FLAGS_MEMORY);
}

// Php code for profiling
...

// Disable profiling
if (extension_loaded('xhprof')) {
    $profiler_namespace = 'myapp';  // namespace for your application
    $xhprof_data = xhprof_disable();
    $xhprof_runs = new XHProfRuns_Default();
    $run_id = $xhprof_runs->save_run($xhprof_data, $profiler_namespace);
}
?>
\end{verbatim}
\end{scriptsize}

\podsekce{Siege}
Vzhledem k tomu, aby mohlo být nasimulováno prostředí vysoké zátěže, byl zvolen nástroj Siege pro zátěžové testy. Siege je tedy nástrojem pro testování webových aplikací a jejich doby odezvy v prostředí vysoké zátěže. Tento nástroj má opět lehkou a přívětivou instalaci, nachází se totiž v základních instalačních balíčcích pro operační systém Linux Debian. Siege je programem spouštěným z příkazové řádky. Jako každý program, tak i siege má samozřejmě svůj konfigurační soubor, který je důležitý hlavně pro nastavení maximální prováděcí doby jednotlivých testů.

Volby parametrů tohoto příkazového programu jsou velice bohaté, ale přitom jednoduché pro pochopení a použití. Základními parametry jsou:

\begin{itemize}
\item c - počet simulovaných konkurenčních uživatelů
\item d - interval zpoždění mezi jednotlivými uživatelskými požadavky
\item r - počet repetic pro zátěžové testy
\end{itemize}

Pro tuto práci byly prováděny zátěžové testy simulováním deseti uživatelů, v intervalu od nuly do jedné sekundy ve třech repeticích. Spuštění vypadá takto:
\begin{scriptsize}
\begin{verbatim}
siege -d1 -c10 -r3 -v http://dp-xskrha.local/hello/Mendelu
\end{verbatim}
\end{scriptsize}


\podsekce{PostgreSQL Explain}
Pro konkrétní analýzu problémových SQL dotazů je potřeba identifikovat a analyzovat jejich exekuční plán. V databázi PostgreSQL a ve většině databázích k tomu slouží příkaz explain, který takto zobrazí exekuční plán. V této práci byla analyzována problémová místa pomocí XHProf profilování, ze kterého se zjistilo, že všechna ploblémová místa souvisí s dotazy pro databázi. Po této fázi identifikace následovala fáze vysvětlení pomocí SQL dotazu EXPLAIN.

Pomocí EXPLAIN je možné vysvětlit všechny kroky exekučního plánu. Je tak možné zjistit jaký způsob prohledání byl zvolen, zda-li sekvenční nebo indexový. Dále je možné zjistit druh spojení, jestli merge join nebo hash join, apod. U jednotlivých kroků exekučního plánu je zobrazena jejich cena, předpokládaný počet řádků a předpokládaný počet sloupců. Tímto způsobem je možné identifikovat slabá místa exekučního plánu a provést možnou úspěšnou optimalizaci.\\
\\
\\ Ukázka analýzy exekučního plánu:
\begin{scriptsize}
\begin{verbatim}
explain analyze select * from film f where film_id in (select film_id from film_actor);
                                   QUERY PLAN
--------------------------------------------------------------------------------------------
Hash Join  (cost=117.26..195.78 rows=977 width=390) (actual time=21.067..26.570 rows=997 loops=1)
  Hash Cond: (f.film_id = film_actor.film_id)
  -> Seq Scan on film f  (cost=0.00..65.00 rows=1000 width=390) 
  	     (actual time=0.016..1.699 rows=1000 loops=1)
  -> Hash (cost=105.05..105.05 rows=977 width=2) (actual time=21.029..21.029 rows=997 loops=1)
    -> HashAggregate  (cost=95.28..105.05 rows=977 width=2) 
           (actual time=17.598..19.298 rows=997 loops=1)
       -> Seq Scan on film_actor  (cost=0.00..81.62 rows=5462 width=2) 
              (actual time=0.012..8.019 rows=5462 loops=1)
Total runtime: 28.020 ms
\end{verbatim}
\end{scriptsize}


% APC
\sekce{Aplikační vrstva PHP}
V aplikační vrstvě byl zvolen pro implementaci programovací jazyk PHP 5.3 běžící na webovém serveru Apache 2.0. Webový server Apache je jedním z nejrozšířenějších a nejpopulárnějších webových serverů na internetu. Byl implementován v roce 1996 v jazyce C++. Jeho instalace, konfigurace a administrace není nikterak složitá. Je podporován většinou poskytovalů webového hostingu v základní konfiguraci. Je to volně použitelný produkt, který obsahuje spoustu různých přídavných módů. Z těchto důvodů byl vybrán pro praktickou část této diplomové práce.

Programovací jazyk PHP se stal jedním z nejpoužívanějších programovacích jazyků pro svoji srozumitelnost, přenositelnost a jednoduchost. Je to dynamicky typovaný programovací jazyk, čili i z těchto důvodů je hodně ohebný. Plně podporuje OOP přístup, čili je možné vyžívat těchto technik včetně návrhových vzorů, které jsou pro pokročilé webové aplikace v prostředí vysoké zátěže velice důležité. Aplikační vrstva samozřejmě podporuje plně koncept návrhového vzoru MVC využíváním MVC frameworku Symfony 2.


\podsekce{Optimalizace pomocí APC}
\label{sec:optim-apc}
Programovací jazyk PHP je sice jednoduchý na vývoj, čitelnost a dynamičnosti, ovšem jeho daň je časová náročnost pro překlad. Tento jazyk je interepretovaný jazyk, čili při jeho interpretaci dochází k překladu do Opcode PHP kompilátorem. Vzniká tak mezikód, který je po skončení překladu vykonán.

K tomu, aby se nemusel pokaždé překládat stejný script PHP kompilátorem, je možné ho uložit do cache pro mezikód, neboli Opcode Cache. K tomuto účelu slouží APC, neboli Alternative Opcode Cache. APC je rozšířením pro PHP vytvořené přímo samotnými tvůrci programovacího jazyka PHP. Toto rozšíření není vůbec náročné na intalaci ani konfiguraci. Dokonce je k němu možné zprovoznit i webové rozhraní ukazující počet úspěšných či neúspěšných dotazů do cache a jiné další statistiky. Prostřednictvím APC programového rozhraní se dají do cache paměti ukládat i jiné další hodnoty přímo ze zdrojových kódů. Úložištěm pro APC je operační paměť RAM. Z toho důvodu je tedy důležité, aby běžel webserver Apache2 stále zapnutý. Při restartu webového serveru dojde k invalidaci celé APC cache paměti.\cite{apc}

Většina interpretovaných jazyků je překládána do nějakého mezikódu. Proto se při žádné změně zdrojových kódů dá využít už jednou zkompilovaných výsledků. Tato forma recyklace zkompilovaného mezikódu dokáže přinést velké výsledky při optimalizaci. U APC jsou tyto výsledky více než viditelné.

\podsekce{Dosažené výsledky}
Pro dosažení výsledků optimalizace aplikační vrstvy bylo vygenerováno prostředí vysoké zátěže deseti konkurenčních uživatelů s intervalem požadavků do jedné sekundy ve třech repeticích. Na aplikačním serveru tak vzniklo deset vláken Apache2 s PHP 5.3 pro každého z uživatelů a celý procesorový výkon byl tak rozdělen rovnoměrně mezi jednotlivé vlákna po deseti procentech. Vytížení procesoru aplikačního serveru tak dosahovalo sta procent, čili maximálního vytížení. Toto prostředí jsem nasimuloval jak pro neoptimalizované prostředí bez APC, tak i pro optimalizovné prostředí s APC. Pro každý požadavek docházelo ke zpracování celého MVC frameworku, čili ke zpracování mnoho funkcí, tříd a metod. Z XHProf profilování jsem vyprofiloval výsledky pro jeden požadavek jak pro situaci s použitím APC, tak i bez použití APC. Výsledky tohoto profilování jsou takovéto:

\begin{itemize}
\item neoptimalované - bez APC - 1,3s
\item optimalizované - s APC - 0,4s
\end{itemize}

Z výsledku vyplývá, že při optimalizaci aplikační vrstvy pomocí APC došlo k zrychlení překladu a provedení PHP skriptů o více než padesát procent, a to jak při jediném požadavku, tak i v prostředí vysoké zátěže. Takovýto fakt se dá určitě označit úspěšnou optimalizací. Alternativou může být použití přístupu s webovým serverem Lighttpd a s cache pamětí pro mezikód eAccelerator. Výsledky by měli být hodně podobné. V dnešních dnech se objevují a publikují zprávy o uvolnění HIP-HOP pro PHP od společnosti Facebook. HIP-HOP používá úplně jiného přístupu pro zrychlení běhu PHP scriptů. Tato varianta je dnes ještě hodně čerstvá a ne tak prověřená, ovšem představuje další možnosti pro optimalizaci aplikační vrstvy s PHP v prostředí vysoké zátěže v budoucích dnech.

\obrazek
\vlozeps{../images/graph-apc.png}{0.4}
\endobr{Graf s výsledky porovnání doby trvání jednotlivých požadavků pro repetice s použitím a bez použití APC}

\obrazek
\vlozeps{../images/top-apc.png}{0.4}
\endobr{Výpis systémových procesů aplikačního serveru s APC v prostředí vysoké zátěže}

\clearpage

\obrazek
\vlozeps{../images/app-architecture.png}{0.5}
\endobr{Výsledné zapojení webové architektury s aplikační vrstvou a APC}



% Databaze
\sekce{Databázová vrstva}
Databázová vrstva je důležitou a nezbytnou součástí webové architektury. Její úloha je perzistence dat pomocí databázového systému. Ovšem přístup k datům může být někdy velice zdlouhavý, až v řádech několika minut a hodin. V prostředí vysoké zátěže dochází obvykle k obrovskému růstu dat a je potřeba optimalizovat databázovou vrstvu tak, aby jejich doba přístupu byla co nejkratší.

V této práci byla vytvořena databáze nad databázovým systémem PostgreSQL. Tento systém je volně dostupný a najde velké uplatnění právě ve webových architekturách. Podporuje všechny standartní databázové operace a přístupy a je oblíben pro svoji spolehlivost.

Databáze modelované aplikace obsahuje záznamy v řádech miliónů řádků. To z toho důvodu, aby bylo nasimulováno prostředí vysoké zátěže i s velkou databází. Datové záznamy byly pro potřeby mé práce vygenerovány a nepředstavují žádnou paralelu s reálnými daty.

\podsekce{Optimalizace databáze}
\label{sec:optim-database}
Před samotnou optimalizací databázové vrstvy nebyla databáze žádným způsobem optimalizována, ať už za pomocí indexace, optimalizace SQL dotazů, segmentováním či vytvořením replikací. Přístup k datům v databázi tak nebyl žádným způsobem efektivní. Jednalo se o znovu se opakující SQL dotazy a dokonce místo jednoho SQL dotazu se objevovalo více SQL dotazů pro zjištění stejné informační hodnoty. Bylo tak rozhodnuto pro aplikaci optimalizace databázové vrstvy pomocí optimalizace SQL dotazů.

Pří procesu optimalizace se napřed určily problematické SQL dotazy pomocí XHProf profilování. Z tohoto procesu bylo zjištěno, které sql dotazy je potřeba zoptimalizovat. Dalším krokem byl rozbor jejich exekučního plánu, vyhledání řešení a jeho aplikace. Řešením optimalizace některých z exukučních plánů byla indexace příslušných sloupců pro nahrazení sekvenčního prohledání za indexové prohledání. Zde je ukázka rozboru neoptimalizovaného exekučního plánu se sekvenčním prohledáním:

\begin{scriptsize}
\begin{verbatim}
SELECT * FROM dp_comment WHERE article_id = 15 ORDER BY create_time DESC;
-------------------------------------------------------------------------
Sort  (cost=121201.07..121201.08 rows=3 width=540) (actual time=16300.440..16300.444 rows=3 loops=1)
  Sort Key: create_time
  Sort Method:  quicksort  Memory: 20kB
  ->  Seq Scan on dp_comment  (cost=0.00..121201.05 rows=3 width=540) 
          (actual time=13.531..16300.393 rows=3 loops=1)
        Filter: (article_id = 15)
Total runtime: 16300.526 ms
\end{verbatim}
\end{scriptsize}

Po optimalizaci je vidět, že sekvenční prohledání bylo odstraněno a nahrazeno indexovým prohledáním, které je daleko efektivnější:

\begin{scriptsize}
\begin{verbatim}
SELECT * FROM dp_comment WHERE article_id = 15 ORDER BY create_time DESC;
-------------------------------------------------------------------------
Sort  (cost=8.47..8.48 rows=3 width=540) (actual time=0.119..0.134 rows=4 loops=1)
  Sort Key: create_time
  Sort Method:  quicksort  Memory: 21kB
  ->  Index Scan using dp_comment_article_id_fk_i on dp_comment  (cost=0.00..8.45 rows=3 width=540) 
          (actual time=0.043..0.068 rows=4 loops=1)
        Index Cond: (article_id = 1441)
Total runtime: 0.303 ms
\end{verbatim}
\end{scriptsize}

\podsekce{Dosažené výsledky}
Při optimalizaci SQL dotazů byly důkladně prozkoumány exekuční plány jednotlivých dlouhotrvajících SQL dotazů. Na spoustě místech byly řešitelné pomocí indexace. Aby byly tyto kroky potvrzeny i v prostředí vysoké zátěže, bylo nasimulováno prostředí vysoké zátěže opět pomocí programu Siege, který vytvořil deset konkurenčních uživatelů s intervalem požadavku do jedné sekundy ve třech repeticích. Test proběhl samozřejmě před optimalizací i po optimalizaci.

Z výsledků experimentu vyplývá, že SQL dotazy, které trvaly několik řádů sekund byly zoptimalizovány až pod dobu jedné sekundy. Z grafu v prostředí vysoké zátěže je vidět, že před optimalizací byla maximální doba jednoho požadavku až 420 sekund. Celý proces byl hodně nestabilní a kolísavý. Po optimalizaci je viditelné ustálení činnosti databázového systému a zmenšení doby odezvy. Zrychlení je vidět až o více než padesát procent. Dalšími budoucími řešeními, která se by se dala aplikovat, mohou být segmentace či replikace databázového systému. Samotná optimalizace SQL dotazů řeší určité problémy, ovšem databáze může přerůst až do takových rozměrů, kdy je potřeba sáhnout k těmto dalším řešením.

Databázová vrstva bývá velice často největším zdrojem zpomalení. Dotazy na tuto vrstvu jsou nejnáročnější ze všech procesů v celé webové architektuře. Proto je velice důležité tento proces nepodceňovat a věnovat tomu patřičné prostředky.

\obrazek
\vlozeps{../images/graph-db.png}{0.4}
\endobr{Graf s výsledky porovnání doby trvání jednotlivých požadavků pro repetice před a po optimalizaci SQL dotazů}

\obrazek
\vlozeps{../images/xhprof-model-db-no-optim.png}{0.4}
\endobr{XHProf profilování aplikačního modelu databázových dotazů před optimalizací SQL dotazů}

\clearpage

\obrazek
\vlozeps{../images/xhprof-model-db-optim.png}{0.4}
\endobr{XHProf profilování aplikačního modelu databázových dotazů po optimalizaci SQL dotazů}


\obrazek
\vlozeps{../images/database-architecture.png}{0.5}
\endobr{Výsledné zapojení webové architektury s optimalizovanou databázovou vrstvou}


% Memcached
\sekce{Aplikační distribuovaná cache}
\label{sec:memcached}
Úkolem aplikační distribuované cache je ukládat jednou dotazovaná data do cache paměti a ušetřit tak SQL dotazy do databáze, které mohou být velice náročné. Zároveň ponechává webovou aplikaci dynamickou. Celý tento proces je řízen aplikací a její logikou, a tak je potřeba už v návrhu počítat s existencí dalšího typu úložiště, s přístupem k tomuto úložišti a s invalidací neplatných dat. Při použití aplikační distribuované cache vrstvy se kladou velké systémové a výpočetní nároky na aplikační vrstvu. Jejím úkolem už tak není jen vykonávat zdrojový kód PHP skriptů a práce s databází, ale navíc i řízení celé logiky aplikační distribuované cache. V této práci jsou uvedeny výsledky, které tato tvrzení dokládají.

\podsekce{Optimalizace aplikace pomocí Memcached}
Ve této práci byla zvolena aplikační distribuovaná cache s názvem Memcached. Memcached obsahuje rozhraní pro práci v různých programovacích jazycích, například v Java, Ruby On Rails, .NET, apod. Somozřejmě obsahuje i rozhraní pro programovací jazyk PHP, použitého v mé studii. PHP rozhraní pro Memcached je součástí doplňkových rozšíření pro PHP, čili instalace tohoto rozhraní je rychlá a bezproblémová. Vzhledem k bohaté podpoře různých programovacích jazyků, je možné použít návrh, přístup a výsledky této studie aplikační distribuované cache Memcached i pro webové architektury implementované v jiných programovacích jazycích než jen PHP.

Memcached je volně šířitelným software s vysokou rychlostí a stabilitou. Své uplatnění najde v prostředích vysoké zátěže, kde dokáže rapidně snížit dobu přístupu k datům a zachovává aplikaci dynamickou. Memcached byla vyvinuta a implentována v jazyce C pro Live Journal v roce 2003, kdy měla tato webová aplikace přístup několika miliónů dynamického zobrazení stránek během jednoho dne. V takovémto prostředí vysoké zátěže obstála a stává se dnes běžnou součástí vrstev webových arhitektur v prostředí vysoké zátěže.

Fyzickým úložištěm pro Memcached je operační paměť RAM. Do paměti ukládá hodnoty na principu Key-Value, čili každá hodnota je ukládána a čtena podle konkrétního klíče. Připojení aplikační vrstvy k jednotlivým serverům s Memcached není nikterak složité. Těchto cache serverů, neboli uzlů, může být i více a je možné určit v jakém poměru se budou hodnoty do jednotlivých uzlů ukládat. Ne všechny uzly totiž mohou mít stejné hardwarové vybavení, zejména stejnou velikost operační paměti RAM. Aplikační vrstva nemusí znát informace o tom, na jakém konkrétním uzlu se uložila jaká hodnota. Pouze zašle Memcached požadavek pro hodnotu podle klíče a Memcached už sama rozhoduje na kterém z uzlů se tato hodnota nachází. Všechny hodnoty jsou ukládány serializované, nebo v textové formě, a nebo v nějakém jiném standardizovaném formátu, který může určit aplikační vrstva.\cite{memcached}

Systém Memcached představuje optimálního kandidáta pro tvorbu aplikační distribuované cache pro dynamické webové aplikace. Ovšem vzhledem k náročnosti požadavků pro tuto vrstvu webové architektury je důležitý správný návrh a implementace aplikace. To z toho důvodu, aby byla ukládána a zobrazována čerstvá, aktuální a správná data pro zobrazení korektních informací pro uživatele webové aplikace.

\podsekce{Specifikace aplikace}
\label{sec:app-model-memcached}
Pro aplikační vrstvu byl použit programovací jazy PHP s MVC frameworkem Symfony 2. Každý MVC framework by měl pracovat s daty a jejich úložištěm ve vrstvě Model. Vyjímkou by neměli být ani data ukládána pomocí distribuované aplikační cache Memcached.

Model aplikační vrstvy je rozdělen na další čtyři vrstvy, kde každá z nich má svůj jasně definovaný účel. První vrstvou je vrstva Service, neboli vrstva, která je přístupna z ostatních vrstev MVC frameworku. Této vrstvě mohou být předány i nějaké parametry. Servisní vrstva požadavek zpracuje, zpracuje předané parametry a předá řízení další vrstvě modelu, kterou je DAO, neboli Data Access Object. Účelem této vrstvy je vybrat způsob přistupu ke konkrétním typům úložišť. Jednotlivé typy úložišť jsou přístupné pomocí vrstvy s názvem Mapper. Pro každý typ úložiště existuje Mapper, který má za úkol realizovat daný požadavek na konkrétní úložiště, například databázi či aplikační distribuovanou cache. Úložiště tak tvoří poslední vrstvu pro Model.

Data, neboli dotazy se kterými aplikace pracuje, mohou být tří druhů z pohledu čtení z úložiště a ukládání do úložiště. Dotazy mohou být buď skalárem, čili jednou hodnotou, nebo entitou, neboli objektem s více atributy, či kolekcí entit. Tyto typy dotazů jsou předány buď databázi a nebo distribuované aplikační cache, podle toho jak rozhodne vrstva DAO. Každý z těchto dotazů definuje svůj SQL dotaz pro načtení z databáze a klíč pod kterým je uložen do Memcached. Do Memcached jsou data ukládána serializovaná, a to z toho důvodu, aby mohla být znovuzkonstruovatelná.

Největší problém obecně pro cache vrstvy bývá jejich invalidace. V distribuovaných aplikačních cache vrstvách mohou vznikat tzv. cache kaskády. Vyjímkou tomu nebylo ani v mém návrhu aplikace. Tyto kaskády vznikají tím, že stejná data jsou interpretována v jiných kontextech. Jakmile dojde ke změně těchto dat, musí se změnit i celá tato kaskáda. Celá kaskáda se tak musí invalidovat. Jedná se o závislosti mezi jinými výsledky dotazů na stejných datech. Jako příklad můžu uvést, že jeden stejný článek se může nacházet v kolekci nejnovějších článků a zároveň v kolekci článků dané kategorie. Jakmile dojde ke změně článku v databázi, je potřeba invalidovat obě dvě tyto kolekce v cache paměti Memcached. V této práci je tato skutečnost řešena pomocí Interface Dependency Injection, která určuje způsob předávání závislostí mezi jednotlivými objekty. Vytvoří se tak nějaká konkrétní kaskáda, která určuje závislosti mezi konkrétními daty a jednotlivými dotazy měnící data aplikace. Jakmile dojde ke změně určitých dat, tak kaskáda invaliduje všechny závislosti dotazů na těchto datech.

Takto jsou splněny všchny podmínky pro správnou práci a organizaci aplikační distribuované cache. Data jsou do cache paměti ukládána v nejmenších a jasně definovaných formátech, podle jednoznačného a konkrétního klíče a jsou ukládána znovuzkonstruovatelná. Invalidace dat uloženách v cache paměti je řešena systémem invalidačních kaskád.

\podsekce{Dosažené výsledky}
Po zhodnocení dosažených výsledků webové architektury s aplikační distribuovanou cache pomocí Memcached bylo potvrzeno další zrychlení odezvy odpovědí na požadavky klientů v prostředí vysoké zátěže. Opět bylo nasimulováno prostředí vysoké zátěže pomocí zátěžových testů programem Siege, kdy odpověď požadovalo deset konkurenčních uživatelů ve stejný moment ve třech repeticích. Z XHProf profilování byly vyprofilovýny výsledky pro jeden požadavek jak pro situaci s použitím aplikační distribuované cache, tak i pro situaci s optimalizovanou databází bez použití aplikační ditribuované cache. Výsledky tohoto profilování jsou takovéto:

\begin{itemize}
\item neoptimalované - bez Memcached - 25,9s
\item optimalizované - s Memcached - 0.95s
\end{itemize}

Výsledky potvrdili, že došlo k velkému zrychlení odpovědí. Zároveň bylo otestováno, že aplikace stále zůstává dynamickou a všechna data jsou invalidována správně a ve správný čas. Ovšem stále zůstává obrovské zatížení aplikační vrstvy. Z tohoto faktu vyplývá, že při použití aplikační distribuované cache je potřeba počítat se zatížením aplikační vrstvy, které je nutno řešit pomocí více aplikačních serverů a vyvažováním zátěže (load balancing) mezi tyto servery (viz. kapitola \ref{sec:load-balancing}). Server určen pro aplikační distribuovanou cache neměl žádné velké vytížení a tudíž se zde nachází potenciál, který se stále jestě může využít.

\obrazek
\vlozeps{../images/graph-memcached.png}{0.4}
\endobr{Graf s výsledky porovnání doby trvání jednotlivých požadavků pro repetice v prostředí s Memcached a v prostředí s optimalizovanou databází PostgreSQL}

\clearpage

\obrazek
\vlozeps{../images/xhprof-model-memcached-no-optim.png}{0.32}
\endobr{XHProf profilování aplikačního modelu dotazů před optimalizací pomocí Memcached}

\obrazek
\vlozeps{../images/xhprof-model-memcached-optim.png}{0.32}
\endobr{XHProf profilování aplikačního modelu dotazů po optimalizaci pomocí Memcached}

\clearpage

\obrazek
\vlozeps{../images/memcached-architecture.png}{0.5}
\endobr{Výsledné zapojení webové architektury s aplikační distribuovanou cache vrstvou Memcached}


% Reverse Proxy Cache
\sekce{Reverzní proxy cache}
\label{sec:reverse-proxy-cache}
Nejrychlejším a nejefektivnější způsobem zůstává stále použití reverzní proxy cache. Ovšem aplikace tak přichází o dynamičnost a stává se více statickou. Ale i tak se dají najít situace, kdy je možné použití statického ukládání do cache paměti reverzní proxy cache. Například archiv článků určitého období může být statického charakteru, poněvadž takovýto obsah se dynamicky často nemění. Existuje spousta programů pro řešení klasické reverzní proxy cache (viz. kapitola \ref{sec:reverse-proxy}). V této části své práce popíšu netradiční způsob pro řešení reverzní proxy cache, ale tento způsob má své uplatnění v praxi a navazuje na předchozí kapitolu \ref{sec:memcached}.

\podsekce{Optimalizace pomocí reverzní proxy cache Nginx s Memcached}
Jedním z moderních nástrojů pro reverzní proxy cache a se nazývá Nginx. Nginx má spoustu dalších funkcionalit a modulů. Obsahuje modul pro webový server, pro rozložení zátěže (load balancing), pro geografické rozložení zátěže, pro servírování obrázků, pro podporu memcached, a spoustu dalších modulů. Tento opravdu silný nástroj byl vytvořen programátorem Igorem Sysoevem v roce 2004 pro druhou největší ruskou webovou aplikaci Rambler.ru, která servírovala přes 500 milionů HTTP odpovědí během jednoho dne. Nginx jako reverzní proxy cache je řízen HTTP hlavičkami jako klasická reverzní proxy cache (viz. kapitola \ref{sec:http-headers}). HTTP odpovědi ukládá do přesně definovaného adresáře souborového systému. Tento klasický způsob se hodí pro skutečný statický obsah, kterým jsou obrázky, CSS soubory, JS soubory apod.\cite{nginx}

V této práci bylo použito Nginx jako reverzní proxy cache s modulem pro Memcached. Tento netradiční způsob řešení reverzní proxy cache s sebou přináší určité výhody. Jednou z výhod je, že řízení Memcached je plně pod kontrolou aplikační vrstvy. Aplikační vrstva ukládá a invaliduje výsledné HTTP odpovědi na HTTP požadavky klientů do Memcached pod URL adresou požadavku. Memcached je použita reverzní proxy cache Nginx pro čtení. Jakmile Nginx obdrží HTTP požadavek a z konfigurace zjistí, že HTTP odpověď je možné hledat pod URL adresou v paměti Memcached, zkusí ji tam najít. Pokud ji Nginx nenalezne, propustí tento požadavek dále na aplikační vrstvu. Aplikační vrstva sestaví HTTP odpověď, uloží ji pod URL adresou HTTP požadavku do cache paměti Memcached, a pošle klientovi. Při příštím HTTP požadavku Nginx nalezne HTTP odpvěď v paměti Memcached a pošle klientovi, aniž by požadavek propustil na aplikační vrstvu. Takovéto chování je obdobné jako při klasickém nastavení reverzní proxy cache, ovšem s tím rozdílem, že ukládání a invalidace nejsou řízeny HTTP hlavičkami. Dalši výhodou může být využití Ajaxu a metodiky aplikační distribuované cache pro vytvoření dynamického přístupu ukládání a invalidace dat do cache paměti pro Memcached a Nginx.\cite{nginx-memcached}

\obrazek
\vlozeps{../images/nginx-memcached.png}{0.5}
\endobr{Schéma webové architektury při použití Nginx s modulem pro Memcached}

\podsekce{Využití Ajax a webových služeb pro NGINX s Memcached}
\label{sec:ajax-nginx-memcached}
Aplikační vrstva nemusí ukládat do cache paměti Memcached pro Nginx pouze celé kompletní HTML stránky, neboli odpovědi pro HTTP požadavky. Může ukládat i další typy odpovědí, jako například Ajaxem standardizovaný JSON, což je druh přenosu dat mezi Aplikační vrstvou a technologií Ajax klientské vrstvy. Díky Ajax tak může dojít k rozdělení jednoho HTTP požadavku na více různých požadavků. Klient zašle HTTP požadavek a Nginx navrátí HTTP odpověď ve formě statické HTML stránky, která obsahuje několik dalších požadavků pomocí Ajax. Odpovědi na tyto Ajax požadavky mohou být dynamického či statického charakteru. Tímto způsobem je webová aplikace rozdělena mezi více webových služeb, které mohou pracovat samostatněji a nezávisle na sobě, a aplikace se tak stává více škálovatelnou.

Vzhledem k tomu, že aplikace a její logika řídí ukládání do cache paměti Memcached, může tak řídit i jejich invalidaci podobným způsobem jako v aplikační distribuované cache (viz. kapitola \ref{sec:app-model-memcached}). Hlavní rozdíl je v tom, že v případě aplikační distribuované cache je práce s cache řízena plně aplikační vrstvou, jak při změně tak čtení. V tomto případě dochází k velkému vytížení aplikační vrstvy (viz. kapitola \ref{sec:memcached}). Kdežto systém webové architektury s Nginx a Memcached je řízen aplikační vrstvou pro změnu a invalidaci dat, a reverzní proxy cache vrstvou pro čtení a získání dat z cache paměti. Dochází tak k hybridnímu způsobu práce s reverzní proxy cache a aplikační distribuovanou cache. Toho je možné využít pro webové služby, které tak mohou být i dynamického charakteru.

\podsekce{Dosažené výsledky}
Z dosažených výsledků vyplývá absolutně nejrychlejší doba pro HTTP odpovědi ze všech uvedených experimentů. Opět bylo nasimulováno prostředí vysoké zátěže pro deset konkurenčních uživatelů v jeden samý okamžik a ve třech repeticích. Ovšem tento experiment má tu nevýhodu, že obsah aplikace se stává statickým. Ovšem při aplikaci myšlenky z kapitoly \ref{sec:ajax-nginx-memcached} jsou HTTP odpovědi servírovány uživateli velice rychle, a jakmile jsou data změněna, může dojít k ivalidaci dat pomocí aplikační vrstvy (viz. kapitola \ref{sec:ajax-nginx-memcached}). Tak se obsah webové aplikace může stát dynamickým. Tento způsob dynamického chování byl implementován v aplikační vrstvě pro Nginx.

\obrazek
\vlozeps{../images/graph-nginx.png}{0.4}
\endobr{Graf s výsledky porovnání doby trvání jednotlivých požadavků pro repetice s reverzní proxy cache Nginx s pamětí Memcached}

\clearpage

\obrazek
\vlozeps{../images/nginx-architecture.png}{0.5}
\endobr{Výsledné zapojení webové architektury s reverzní proxy cache vrstvou Nginx s pamětí Memcached}



% Diskuze
\kapitola{Diskuze}
Tato práce se nejvíce zaměřila na jednotlivé vrstvy webové architektury, obzvláště na vrstvy serverové části. Celkem byly provedeny čtyři větší experimenty, jeden experiment pro aplikační vrstvu, jeden pro databázovou vrstvu, jeden pro aplikační distribuovanou cache vrstvu a jeden pro reverzní proxy cache vrstvu. Pro každý z testů byla navržena, implementována, otestována a vyhodnocena jejich webová architektura, konfigurace, funkcionalita, zátěžové testy a schopnost obstát v prostředí vysoké zátěže.

První experiment se týkal aplikační vrstvy a možnosti využití Opcode Cache pro programovací jazyk PHP (viz. kapitola \ref{sec:optim-apc}). Konfigurace, implementace a realizace tohoto experimentu nebyla až tak náročná a pracná. Vzhledem k nastudovaným teoretickým základům, kdy bylo známo jakou cestou se vydat, nebyl experiment až tak složitý a výsledky jsou více než dobré. Tento postup je tedy možné doporučit pro ostré nasazení. V prostředí s opravdu vysokou zátěží je nasazení více aplikačních serverů pro rozložení zátěže (load balancing) nevyhnutelné.

Druhý experiment pracoval se standartní třívrstvou architekturou, tj. klientem, aplikačním serverem a databázovým systémem (viz. kapitola \ref{sec:optim-database}). Tento experiment byl zaměřen na databázový systém, jeho přístupnost a časovou odezvu na SQL dotazy v prostředí vysoké zátěže. V tomto směru bylo zjištěno, že optimalizace databáze je velice důležitá, protože se přístup a odpovědi na SQL dotazy mohou zrychlit v řádech sekund, minut i hodin. Samozřejmě jakmile se prostředí vysoké zátěže začne zvětšovat a začne ještě více růst zatížení databáze, je potřeba sáhnout k dalším krokům jako například partitioning nebo replikace. Samozřejmě v architektuře webových systémů bývá databázová vrstva tou nejvytíženější a nejpomalejší vrstvou. Proto je dobré zaměřit pozornost i na to, jak zmenšit počet SQL dotazů do databáze.

Ve třetím experimentu došlo k rozšíření třívrstvé architektury o vrstvu aplikační distribuované cache (viz. kapitola \ref{sec:memcached}). Právě diký této vrstvě je možné získat rychlejší přístup k již jednou načteným datům z databáze. Zároveň zůstává obsah webové aplikace dynamický. Ovšem je nutné zmínit, že zde zůstává velké zatížení aplikační vrstvy. Proto může v prostředí vysoké zátěže nastat situace, kdy je potřeba mít více aplikačních serverů pro rozložení zátěže. Výsledky testů simulovaného prostředí vysoké zátěže byly rozhodně lepší s využitím aplikační distribuované cache Memcached než výsledky pouze s databází. Ovšem je potřeba přihlédnout k nutnosti zajistit funkcionalitu aplikační distribuované cache v jádru aplikace a v její logice. Je potřeba zajistit aplikaci přístup ke cache paměti, zajistit ukládání dat ve spravném, dohodnutém a znovuzkonstruovatelném formátu, a hlavně zajistit jejich správnou a včasnou invalidaci. S požadavkem aplikační distribuované cache je potřeba počítat již při návrhu aplikace, protože jinak může docházet k častým chybám a náklady, ať už časové či finanční, na zavedení této vrstvy mohou být vysoké.

V posledním experimentu proběhlo zkombinování reverzní proxy cache Nginx s aplikační distribuovanou cache Memcached (viz. kapitola \ref{sec:reverse-proxy-cache}). První HTTP požadavky zpracovala aplikační vrstva, vytvořila HTTP odpověď a uložila ji do cache paměti Memcached pro reverzní proxy cache Nginx. Při příštím dotazu našla reverzní proxy cache odpověď v cache paměti a okamžitě ji vrátila klientovi. Invalidace těchto odpovědí probíhá automaticky pomocí Memcached a časového razítka. Tento způsob práce s obsahem webové aplikace se tak stává statickým. Ovšem vzhledem k tomu, že odpovědi ukládá aplikační vrstva, může tyto odpovědi také invalidovat podobně jako v případě aplikační distribuované cache. Jeden HTTP požadavek se tak dá rozložit na více požadavků pomocí technologie Ajax. Odpovědi na jednotlivé požadavky Ajax jsou také ukládány do cache paměti Memcached a jejich invalidace může proběhnout ihned při změně. Dochází tak k hybridnímu využití reverzní proxy cache a aplikační distribuované cache. Výsledky pro tento způsob práce byly více než uspokojivé. Obsah webové aplikace je dynamický a rychlý, a to díky režii ukládání a invalidace na straně aplikační distriboavané cache a režii čtení na straně reverzní proxy cache.

% Zaver
\kapitola{Závěr}
Závěrem je nutno říci, že webová architektura je natolik komplexní a náročný systém, že v něm neexistuje jedno či pár pravidel, která je nutno dodržet a díky kterým bude webová aplikace připravená, optimalizovaná a provozuschopná v prostředí vysoké zátěže. Existuje spousta osvědčených nástrojů a postupů řešení, které umí pomoci architektuře k odlehčení vytíženosti, ovšem je nutno je brát pouze jako rady a návody, ne jako závazná pravidla. Každá webová aplikace je totiž svým způsobem jedinečná, a vyžaduje tak unikátní přístup řešení optimalizace. 

V první fázi je nejdůležitější identifikovat zdroj vytížení. Jedná-li se o nějaký z DoS útoků, nebo o nárazovou vytíženost, či o dlouhodobé kontinuální vytížení. Je možné se zaměřit i na geografický původ tohoto vytížení. Může se vyskytnout i chyba v konfiguraci či implementaci některé z vrstev architektury. K identifikování takových problémů jsou důležité profilery. Vždy je dobré vědět, kdo, kdy, kde a jak stojí za vytížením aplikace.

Dále je nutné rozlišovat, jaký typ dat aplikace poskytuje a která data jsou v prostředí vysoké zátěže. Podle toho jestli se jedná o data statická či dynamická, je možné určit, jakou další cestou optimalizace se vydat. Důležitá je otázka zpracování dat. S webovou architekturou v prostředí vysoké zátěže souvisí i vysoká míra dat nutných ke zpracovávání databází, ke které je nutno přistupovat se zvláštní obezřetností, poněvadž může být tou nejvytíženější vrstvou architektury.

Pokud je možné předvídat vysoké vytížení aplikace, je dobré webovou architekturu na takové vytížení připravit. Když se webová aplikace od začátku vyvyjí tak, aby byla lehce škálovatelná, její optimalaze a odlehčení zátěže bude o dost jednodušší. Škálovatelnost je jedním z nejdůležitějších faktorů pro optimální chod aplikací ve vysokém vytížení. Je totiž dobré umět do webové architektury přidat jiné vrstvy, funkcionality a uzly tak, aby odlehčily co nejvíce jiným vrstvám. Je důležité kombinovat různá řešení a přístupy.

Nezbytné je zvážit jaké jsou dostupné možnosti řešení. Ať už se jedná o možnosti časové, finanční či jiné. Některá řešení jsou náročná časově, jiná zase finančně. Může nastat i situace, kdy je stávající webová architektura špatně navržena, a tak ji lze jen těžko, či vůbec, rozšířit. Ovšem ten, kdo rozhoduje o způsobu provedení optimalizace a odlehčení vytíženosti nejsou programátoři, administrátoři či softwarový inženýři, ale projektové vedení. To rozhoduje, jakou cestou se webová aplikace bude ubírat, jaký je její cíl, jak se má chovat k uživatelům a jaký je její smysl. Otázkou zůstává, jsou-li k rozhodnutím vždy dostatečně kompetentní z pohledu svých technických znalostí. V mnoha případech se ale jedná o zhodnocení faktorů finančních, časových a technických. Ne každý přístup k řešení vysoké zátěže je efektivní a ne každý přístup je levný. Většinou se jedná o kompromis mezi dostupnými finančními a časovými možnostmi.


\begin{literatura}

\citace{sledovani-zatizeni}{Rankin, 2010}{\autor{Kyle Rankin}
%\citace{sledovani-zatizeni}{1}{\autor{Kyle Rankin}
\nazev{Hack and / - Linux Troubleshooting, Part I: High Load} [online]. Linux Journal, 1.května 2010. URL: http://www.linuxjournal.com/magazine/hack-and-linux-troubleshooting-part-i-high-load}

\citace{dos}{Khan, 2009}{\autor{Faisal Khan}
%\citace{dos}{2}{\autor{Faisal Khan}
\nazev{Dos Attacks Overview - What are DoS attacks} [online]. Dos Attacks, 5.září 2009. URL: http://dos-attacks.com/what-are-dos-attacks/}

\citace{anonymous}{Čepský, 2012}{\autor{Pavel Čepský}
%\citace{anonymous}{3}{\autor{Pavel Čepský}
\nazev{Útoky jménem Anonymous: Jak se rodí hackeři?} [online]. Lupa.cz, 7.února 2012. URL: http://www.lupa.cz/clanky/utoky-jmenem-anonymous-jak-se-rodi-hackeri/}

\citace{tri-vrstvy}{Zendulka, 2005}{\autor{Doc.Ing.Jaroslav Zendulka,CSc.}
%\citace{tri-vrstvy}{4}{\autor{Doc.Ing.Jaroslav Zendulka,CSc.}
\nazev{10. Architektura klient/server a třívrstvá architektura} [online]. Brno: VUT-FIT, 2005. URL: http://www.fit.vutbr.cz/study/courses/DSI/public/pdf/nove/10\_clsrv.pdf}

\citace{ajax}{McLaughlin, 2005}{\autor{Brett McLaughlin}
%\citace{ajax}{5}{\autor{Brett McLaughlin}
\nazev{Mastering Ajax} [online]. Ibm develper works, 6.prosince 2005. URL: http://www.ibm.com/developerworks/web/library/wa-ajaxintro1/index.html}

\citace{design-patterns}{Pecinovský, 2007}{\autor{Rudolf Pecinovský}
%\citace{design-patterns}{6}{\autor{Rudolf Pecinovský}
\nazev{Návrhové vzory : 33 vzorových postupů pro objektové programování} 1. vyd. Brno: Computer Press, 2007. 527 s. ISBN 978-80-251-1582-4}

\citace{optimalizace-sql}{Blaha, 2007}{\autor{Bohdan Blaha}
%\citace{optimalizace-sql}{7}{\autor{Bohdan Blaha}
\nazev{SQL Optimalizace v Oracle} Praha: Unicorn College, 2010. 47 s. URL:
http://www.unicorncollege.cz/katalog-bakalarskych-praci/bohdan-blaha/attachments/Blaha\_Bohdan\_-\_Optimalizace\_SQL\_dotaz\%C5\%AF\_v\_datab\%C3\%A1zi\_Oracle.pdf}

\citace{partitioning-db}{White, 2009}{\autor{Eli White}
%\citace{partitioning-db}{8}{\autor{Eli White}
\nazev{Habits of Highly Scalable Web Applications} DCPHP Konference. 2009}

\citace{replikace}{Vondra, 2011}{\autor{Tomáš Vondra}
%\citace{replikace}{9}{\autor{Tomáš Vondra}
\nazev{Replikace v PostgreSQL} CSPUG Konference. Praha, 2011}

%\citace{rfc-http}{RFC:2616, 1999}{\autor{R. Fielding, UC Irvine, J. Gettys, J. Mogul, Compaq, H. Frystyk, L. Masinter, Xerox, P. Leach, Microsoft, T. Berners-Lee, W3C/MIT}
\citace{rfc-http}{RFC:2616, 1999}{\autor{R. Fielding, UC Irvine, J. Gettys, J. Mogul, Compaq, H. Frystyk, L. Masinter, Xerox, P. Leach, Microsoft, T. Berners-Lee, W3C/MIT}
\nazev{RFC:2616 - Hypertext Transfer Protocol -- HTTP/1.1}}

\citace{proxy-cache}{Nottingham, 2012}{\autor{Mark Nottingham}
%\citace{proxy-cache}{11}{\autor{Mark Nottingham}
\nazev{CACHING TUTORIAL for Web Authors and Webmasters} [online]. Mark Nottingham, 1998-2012. URL: http://www.mnot.net/cache\_docs/}

\citace{xhprof}{Onderka, 2011}{\autor{Jakub Onderka}
%\citace{xhprof}{12}{\autor{Jakub Onderka}
\nazev{Profilování PHP skriptů pomocí XHProf} [online]. Zdrojak.cz, 24.ledna 2011. URL: http://www.zdrojak.cz/clanky/profilovani-php-skriptu-pomoci-xhprof/}

%\citace{apc}{13}{\autor{Vito Chin}
\citace{apc}{Chin, 2010}{\autor{Vito Chin}
\nazev{Understanding APC} [online]. Techportal Ibuildings, 7.října 2010. URL: http://techportal.ibuildings.com/2010/10/07/understanding-apc/}

%\citace{memcached}{14}{\autor{Brad Fitzpatrick}
\citace{memcached}{Fitzpatrick, 2004}{\autor{Brad Fitzpatrick}
\nazev{Distributed Caching with Memcached} [online]. Linux Journal, 1.srpna 2004. URL: http://www.linuxjournal.com/article/7451}

%\citace{nginx}{15}{\autor{Will Reese}
\citace{nginx}{Reese, 2008}{\autor{Will Reese}
\nazev{Nginx: the High-Performance Web Server and Reverse Proxy} [online]. Linux Journal, 1.září 2008. URL: http://www.linuxjournal.com/magazine/nginx-high-performance-web-server-and-reverse-proxy}

%\citace{nginx-memcached}{16}{\autor{Ilya Grigorik}
\citace{nginx-memcached}{Grigorik, 2008}{\autor{Ilya Grigorik}
\nazev{Nginx and Memcached, a 400\% boost!} [online]. Ingvita, 11.února 2008. URL: http://www.igvita.com/2008/02/11/nginx-and-memcached-a-400-boost/}

%\citace{cdn}{17}{\autor{Bc. Pavel Mikulka}
\citace{cdn}{Mikulka, 2008}{\autor{Bc. Pavel Mikulka}
\nazev{Implementace CDN a clusteringu v prostředí GNU/LINUX s testy výkonnosti}, Brno: VUT, 2008. 65 s. URL: http://www.vutbr.cz/www\_base/zav\_prace\_soubor\_verejne.php?file\_id=7793} 

%\citace{virtual}{18}{\autor{Petr Hrůša}
\citace{virtual}{Hrůša, 2011}{\autor{Petr Hrůša}
\nazev{Výhody a nevýhody virtualizace platforem a aktuální nabídka} [online]. Aquasoft, 24.listopadu 2011. URL: http://www.aquasoft.eu/blog/nazor_odbornika.php?nazor=450} 


\end{literatura}

% Prilohy
\prilohy

\priloha{APC webové rozhraní}
\vlozeps{../images/apc-web.png}{0.5}

\priloha{XHProf graf závislostí funkcí a metod Symfony2}
\vlozeps{../images/callgraph-xhprof.png}{0.275}

\priloha{AJAX dynamické požadavky pro reverzní proxy cache Nginx}
\vlozeps{../images/ajax-nginx.png}{0.4}

\priloha{DVD s aplikací pro aplikační distribuovanou cache Memcached}

\end{document}