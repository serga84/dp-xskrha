% preambule dokumentu
\documentclass[12pt]{article}
%\usepackage[czech]{babel}
%\usepackage[utf8]{inputenc}
%\usepackage[pdfborder=0]{hyperref}
\usepackage{czech, dipp}
%\usepackage{stencl/dipp_utf}
%\usepackage{graphicx}
%\usepackage{textcomp}
%\usepackage{amssymb}
%\usepackage{amsmath}
%\usepackage{eurosym}
\pagestyle{headings}

\begin{document}


% uvodni cast zaverecne prace
\titul{Webová architektura v prostøedí vysoké zátì¾e}{Bc. Jakub ©krha}{Ing. Michael ©tencl, Ph.D.}{Brno 2012}
\podekovani{Chtìl bych podìkovat svému vedoucímu Ing. Michaelu ©tenclovi, Ph.D., za odborné vedení této diplomové práce. Zejména bych chtìl podìkovat Ondøeji Procházkovi za konzultace a nasmìrování pro vyøe¹ení praktické èásti, která díky tomu odrá¾í pou¾ití v reálném produkèním prostøedí. Také bych chtìl podìkovat Lucii Palkoskové za trpìlivost a podporu pøi psaní této diplomové práce a své rodinì za podporu pøi celém mém studiu.}

\prohlaseni{Prohla¹uji, ¾e jsem tuto práci napsal a vyøe¹il samostatnì s pou¾itím literatury, kterou uvádím v seznamu.}{V Brnì dne 21.5.2012}

\abstract{\textsc{Skrha, J.} \textit{Web architecture in high load environment.} 
Diploma thesis. Brno, 2012.}
{This diploma thesis describes web architecture in high load environment. The thesis contains description of layers, theirs purpose and functionality of web architecture. The aim of thesis is optimalization on individual layers, particularly on application layer, database layer, application distributed cache layer and reverse proxy cache layer. For these layers, presented solutions are based on real production projects such as Linux Debian, Apache2, PHP, PostgreSQL, Memcached and Nginx.}

\abstrakt{\textsc{©krha, J.} \textit{Webová architektura v prostøedí vysoké zátì¾e.} 
Diplomová práce. Brno, 2012.}
{Tato diplomová práce popisuje webovou architekturu v prostøedí vysoké zátì¾e. V práci jsou popsány její vrstvy, jejich úèel a funkènost pro webovou architekturu. Práce se zabývá mo¾ností optimalizace na jednotlivých vrstvách webové architektury, zejména aplikaèní vrstvou, databázovou vrstvou, aplikaèní distribuovanou cache vrstvou a reverzní proxy cache vrstvou. Pro tyto vrstvy jsou uvedena vybraná øe¹ení odrá¾ející reálné produkèní nasazení v prostøedí Linux Debian, Apache2, PHP, PostgreSQL, Memcached a Nginx.}


\obsah
\cislovat{3}


% Uvod
\kapitola{Úvod}
V 80. letech 20. století, tedy ve dnech, kdy vznikal internet, nikdo netu¹il, ¾e jeho význam, dùle¾itost a popularita tak markantnì vzroste. Dnes, v 2. dekádì 21. století, je internet a web nedílnou souèástí firem, organizací, komunikace, zábavy, zpravodajství, obchodu, slu¾eb a ¾ivota bì¾ných lidí. Internet se stává dùle¾itou vìdeckou disciplínou nejenom na poli informaèních technologií. Internetem se zabývají oblasti vývoje hardware a software, poèítaèové sítì, aplikaèní a komunikaèní protokoly, u¾ivatelská rozhraní a design, ekonomika a marketing, copywriting, projektové øízení, databázové systémy a mnoho dal¹ích odvìtví. Jednou z oblastí je i webová architektura v prostøedí vysoké zátì¾e.

Úspìch internetových a webových projektù je pøímo úmìrný vý¹i náv¹tìvnosti, míøe pou¾ívání, poètu registrací a samozøejmì výdìlku z aplikace. Obecnì se dá pøedpokládat, ¾e èím je vìt¹í náv¹tìvnost projektu, tím jsou vìt¹í i zisky. A» u¾ díky reklamní èinnosti èi placenným slu¾bám. Ov¹em zde se dá velice jasnì konstatovat, ¾e tyto výdìlky nejsou a¾ tak lehce získané. Nejenom, ¾e si musí aplikace získat své u¾ivatele, ale musí øe¹it problémy s obrovským poètem u¾ivatelù. Tím vzniká prostøedí vysoké zátì¾e pro webovou architekturu, které je potøeba optimalizovat.

\sekce{Cíl práce}
Cílem této práce je provést rozbor webové architektury, jejich vrstev, mo¾ností optimalizace a provést srovnání dílèích øe¹ení v prostøedí vysoké zátì¾e. Práce se zamìøuje na øe¹ení serverové èásti webové architektury. Úkolem je vytvoøit prototyp serverové èásti webové architektury s aplikaèní vrstvou, databázovou vrstvou a cache vrstvou a nasimulovat prostøedí vysoké zátì¾e. Je potøeba navrhnout a implementovat øe¹ení optimalizací jednotlivých vrstev serverové èásti a porovnat výsledky pøed a po optimalizaci. Dùle¾itou souèástí této práce se má stát aplikace s plnou podporou ukládání a ètení aplikaèních a databázových dat pomocí pamìti cache. Výstupem mají být jednotlivé výsledky zátì¾ových testù a profilovacích charakteristik srovnávajících dílèí zpùsoby øe¹ení.

% Nezadouci vlivy
\kapitola{Ne¾ádoucí vlivy a dùsledky vysoké zátì¾e}
Vysoká zátì¾ mù¾e mít ve své podstatì nìkolik ne¾ádoucích vlivù, které mù¾ou mít a¾ katastrofický scénáø. Mù¾e docházet k takovému zatí¾ení aplikace, ¾e odpovìdi na jednotlivé po¾adavky mohou trvat velmi dlouhou dobu. Tím pádem se bude u¾ivatel rozhodovat, zda-li pøí¹tì nav¹tíví tuto webovou aplikaci, èi zkusí nìkterou z jiných mo¾ných konkurenèních alternativ. Tento velice nepøíznivý scénáø mù¾e být je¹tì hor¹í. A to v pøípadì, ¾e díky velkému zatí¾ení dojde dokonce k výpadku celé aplikace, a tím pádem u¾ se u¾ivateli nedostane vùbec ¾ádné odpovìdi na jeho po¾adavek. Pøi takovém scénáøi existuje vysoká pravdìpodobnost ztráty u¾ivatelù, co¾ mù¾e znamenat velký pokles ziskù pro firmu èi spoleènost.

Po technické stránce se pøi velké zátì¾i vytvoøí pro ka¾dý po¾adavek celý samostatný proces èi vlákno procesu, které si klade nároky na procesor CPU a operaèní pamì» RAM serveru. Vznikají tak i procesy, které musí èekat na pøidìlení tìchto prostøedkù, a tím pádem roste zatí¾ení, které mù¾e server vytí¾it do té míry, ¾e nebude provozuschopný. Takové zatí¾ení je mo¾né pozorovat pøi výpisu právì bì¾ících procesù a jejich vytí¾ení na RAM èi CPU (napøíklad pøíkazem top). Dále je mo¾no pozorovat tzv. Load Average (napøíklad pøíkazem uptime), které pøedstavuje poèet procesù èekajících na pøidìlení prostøedkù bìhem jedné, pìti èi patnácti minut. Takto je mo¾né sledovat ne¾ádoucí vlivy vysoké zátì¾e na úrovni jednotlivých serverù.\cite{sledovani-zatizeni}

Je nutné podotknout, ¾e existuje i jeden skrytý a ne tak viditelný dùsledek vysoké zátì¾e. Tím je fakt, ¾e jakmile se zaène zvedat náv¹tìvnost, projektové vedení si klade po¾adavek, aby tento nárùst u¾ivatelù ji¾ zùstal, a dokonce se i zvìt¹oval. A to v¹e z toho dùvodu, ¾e velký poèet u¾ivatelù znamená sice velkou zátì¾ pro aplikaci, ov¹em také velký finanèní pøínos pro firmu.



% Zneuziti
\kapitola{Zneu¾ití vysoké zátì¾e}
Z ne¾ádoucích vlivù a dùsledkù uvedených v pøedchozí kapitole vyplývá, ¾e rostoucí zátì¾ mù¾e zpùsobit katastrofické scénáøe, èili mù¾e negativnì pùsobit na celou aplikaci. Tento poznatek pøedstavuje obrovské riziko pøi jeho zneu¾ití. Zpravidla mù¾e být zneu¾ití vysoké zátì¾e zpùsobeno úmyslným èi neúmyslným chováním nìjaké organizace èi jedince. Takové zneu¾ití má svoji oporu i v zákonech, kde hrozí a¾ odnìtí svobody a¾ na nìkolik let.

U webových projektù je mo¾né z tìch neúmyslných zneu¾ití zmínit napøíklad nìkteré klientské chyby programù èi vìt¹í míru indexace robotù internetových vyhledáváèù. Roboti vyhledávaèù pravidelnì prochází webovou aplikaci a indexují její jednotlivé èásti a tyto výsledky zohledòují následnì ve svých výsledcích ve vyhledávání. Tito roboti jsou tak souèástí vytí¾ení architektury.

Tím druhým, a daleko nebezpeènìj¹ím, úmyslným zpùsobem zneu¾ití lze mnohdy zpùsobit daleko vìt¹í ¹kody. Toto úmyslné chování u¾ je klasifikováno jako útok na webovou aplikaci za který hrozí postih podle zákona. Tyto útoky jsou nazývány DoS, neboli Denial of Service. Jejich cílem je ochromit infrastrukturu celé webové architektury pøehlcením po¾adavkù, na které aplikace bude vytváøet odpovìdi. Tyty útoky vyu¾ívají chyb, nedostatkù èi nedokonalostí protokolù ICMP, TCP, UDP a jiných protokolù èi samotných webových aplikací. Napøíklad útok s názvem Tcp Syn Flood, pøi kterém útoèník vytí¾í aplikaci SYN pakety pro navázání spojení, vyu¾ívá nedokonalosti TCP protokolu. Dal¹ími útoky vyu¾ívajícími nedokonalostí mohou být ICMP Flood, Ping of Death, Smurf Attack, IP Spoofing, Fraggle Attack, Teardrop, Application level aj. Ov¹em proti vìt¹inì zmínìných útokù u¾ dnes existuje ochrana ve formì servisních aktualizací systémù a programù nebo lehké konfigurace jednotlivých èástí aplikace. \cite{dos}

Co ov¹em v dne¹ní dobì pøedstavuje daleko vìt¹í nebezpeèí, jsou útoky typu DDoS, neboli Distributed Denial of Service. V tomto pøípadì je princip útoku obdobný jako u DoS, ov¹em s tím rozdílem, ¾e je distribuovaný. Takový útok je spu¹tìn z nìkolika stanic, nìkolika u¾ivateli a pomocí rùzných nástrojù. Tento zpùsob je daleko organizoavnìj¹í a daleko nebezpeènìj¹í a uèinnìj¹í. \cite{dos}

V souèasnosti se stává symbolem boje za svobodu internetu skupina s názvem Anonymous, která vyu¾ívá útokù DDoS. Pøi svých útocích vyu¾ívají napøíklad útoky typu Slowloris, kdy útoèník vyu¾ívá protokolu HTTP na aplikaèní úrovni a vy¾aduje celou odpovìï na svùj po¾adavek. Pøi navázaném spojení ov¹em odesílá HTTP hlavièky co nejpomaleji, aby tak co nejvíce prodlou¾ili dobu spojení a získal prostor pro vytvoøení dal¹ího spojení, èili dal¹í zátì¾e. Tato skupina napadá webové aplikace veøejností neoblíbených politických stran, vládních organizací, protipirátských asociací a jiných subjektù. Díky tomu si získávají obrovskou podporu ve spoleènosti i médiích, která s jejich kroky souhlasí. Dokonce pro své útoky vyu¾ívají i pøíznivcù z øad veøejnosti, kteøí nemusí být specialisty v oboru informaèních technologií. Staèí jim pouze stáhnout si upravený program, v urèený èas ho spustit a pøipojit se do internetové sítì. Útoky probíhají neohlá¹enì, organizovanì a ditribuovanì. Otázkou zùstává, kdy jejich konání za¹ti»ující se honosnými cíli, pøeroste ve vydírání, snahy o posílení moci, èi pokusù o finanèní obohacení. V ten moment i spoleènost, která je v tyto dny podporuje, mù¾e pocítit jejich nebezpeènost. I v historii lidstva nalezneme spoustu skupin a organizací, které byly lidmi podporovány a nakonec se z nich stal symbol krutosti, tyranie, útlaku a ne¹tìstí. Proto je dùle¾ité jejich útoky nepodceòovat a umìt se bránit. Tato práce se nezabývá konkrétním øe¹ením nìkterého z typù útokù, ale zabývá se obecnì vysokou zátì¾í, a zpùsoby, kterými lze ustát obrovský narùst zátì¾e, tedy i nìjaký útok. \cite{anonymous}



% Tri a vice vrstev
\kapitola{Tøí a vícevrstvá architektura webových systémù}
Webová architektura je ve svém základu tøívrstvá. První vrstvu tvoøí klient, neboli u¾ivatel, se svým hardware, software a svými aplikaèními po¾adavky. Druhou vrstvu tvoøí aplikaèní vrstva, která zpracovává po¾adavky pro aplikaci, tedy po¾adavky klienta. Aplikaèní vrstva tento po¾adavek zpracuje, vytvoøí odpovìï a za¹le zpìt klientovi. Ov¹em k tomu, aby mohla tuto odpovìï vytvoøit, potøebuje i data aplikace, která jsou ulo¾ena v perzistentní databázi, která tvoøí tøetí a poslední vrstvu tøívrstvé architektury. Ka¾dá z vrstev, tedy prezentaèní, aplikaèní i datová, má své místo a význam v aplikaci.\cite{tri-vrstvy}

\obrazek
\vlozeps{../images/3layer.png}{0.5}
\endobr{Tøí vrstvá architektura webových aplikací}

V architektuøe webových aplikací s vysokou zátì¾í u¾ je potøeba jiný pøístup. V tomto pøípadì se dá øíci, ¾e je tøívrstvá architektura nedostaèující. Je potøeba poèítat se sí»ovími prvky pro load balancing, s více aplikaèními uzly, s databázovými replikacemi, s DNS øe¹ením pro geografické rozdìlení zátì¾e, s CDN pro rozdìlení zátì¾e pøidìlování statického obsahu, s vrstvami pro cache aplikace a s dal¹ími vrstvami pro backendové èi frontendové aplikace a slu¾by. V tomto pøípadì neexistuje ¾ádné jasnì dané a pevné øe¹ení, ka¾dá aplikace si s sebou nese svou individuální a specifickou strategii, i kdy¾ nìkteré osvìdèené postupy se vyu¾ívají opakovanì. Tyto strategie nesou název vícevrstvá architektura.

\obrazek
\vlozeps{../images/wikimedia.png}{0.325}
\endobr{Webová architektura spoleènosti Wikimedia provozující Wikipedia.org}

Nutkno podoknout, ¾e webové architektury vyu¾ívají nejèastìji ke své komunikaci mezi klientem a architekturou protokol HTTP, který vyu¾ívá portu èíslo 80 a protokolu TCP pro komunikaci. Proto je celá tato odborná studie zalo¾ena na práci s tímto protokolem.

\kapitola{Typy webového obsahu}
Obsah webových aplikací je rozdìlen na dva typy. Obsah mù¾e být buï statického, nebo dynamického charakteru. Jak u¾ vyplývá z obecné teorie systémù, statický obsah je koneèný, transaprentní a mìní se podle pøedepsaných pravidel, zatím co dynamický obsah se mìní v závislosti na èase a jiných nepøedvídatelných okolnostech. 

Pod pojmem statický obsah tedy mù¾eme chápat videa, obrázky a nebo statické HTML stránky. Jedná se o obsah, který se moc èasto nemìní, nebo známe jeho pøesnou ¾ivotnost, a doká¾eme urèit, kdy pøesnì se má mìnit. Napøíklad invalidace u statického obsahu probìhne pouze jednou za deset minut. A i kdy¾ je obsah zmìnìn uprostøed tohoto intervalu, zmìna se projeví a¾ v pøelomu tìchto pravidelných desetiminutových intervalù, tedy a¾ po invalidaci. Obsah je tak celých deset minut statický a nemìnný.

Naopak dynamický obsah se mù¾e zmìnit kdykoli, nepøedvídatelnì, typicky na nìjaký u¾ivatelùv podnìt, a nebo v závislosti na èase. Pøíkladem mù¾e být nákupní ko¹ík v internetovém obchodì, který se mìní v závislosti na u¾ivatelovì èinnosti. Dále napøíklad pøi vlo¾ení komentáøe pod urèitý èlánek se tento komentáø zobrazí ihned v seznamu komentáøù. Takový obsah se pak tì¾ko ukládá do cache pamìti, dokonce je nároèný i pro rozlo¾ení zátì¾e, ponìvad¾ musí být zachováno u¾ivatelovo sezení s aplikací (session).

Z uvedených vlastností vyplývá, ¾e správa statického obsahu je jednodu¹¹í, kde¾to správa dynamického obsahu je nároènìj¹í. Dynamický pøístup èasto pøedpokládá propu¹tìní po¾adavku a¾ na aplikaèní server, který urèí výsledek. Statický obsah lze jednodu¹e ukládat do cache pamìti, proto¾e známe jeho pøesnou dobu platnosti. V této práci jsou popsány, analyzovány a testovány oba dva pøístupy a je srovnán jejich pøínos jak z pohledu aplikace, tak z pohledu nároènosti na vybudování.

% Aplikacni vrstva
\kapitola{Aplikaèní vrstva}
Aplikaèní vrstva pøedstavuje jádro webové architektury. Jejím úèelem je pøíjmout a zpracovat klientùv po¾adavek, vytvoøit odpovìï a tuto odpovìï zaslat nazpìt klientovi. Na aplikaèní vrstvu jsou tak kladeny úkoly celé re¾ie procesu tvorby odpovìdi, a tím pádem má velkou zoodpovìdnost a mnohdy èelí i nejvìt¹í zátì¾i.

\sekce{Webová aplikaèní architektura MVC}
V dne¹ní moderní aplikaèní vrstvì se pou¾ívá aplikaèní architektura návrhového vzoru MVC pro pøehlednìj¹í a rychlej¹í zpùsob tvorby aplikace. Tato zkratka vychází ze slov Model, View a Controller, která oznaèují tøi základní vrstvy aplikaèní architektury. Tento návrhový vzor èasto bývá oznaèován také jako MVC framework, který rozdìluje aplikaci do tøí vrstev. \cite{design-patterns}

Controller je vrstva, která vykonává akci konkrétního po¾adavku. Zpracovává pøíchozí data, parametry a atributy dané akce od u¾ivatele, provádí jejich kontrolu a formátování. Stará se i o zabezpeèení této akce. Èasto spolupracuje s vrstvou Model, které pøedává po¾adavky na data aplikace, a tato data dále zpracovává pro pøedání do vrstvy View. \cite{design-patterns}

Model má za úkol pøistupovat k datovým úlo¾i¹tím, a to buï k perzistentní databázi, nebo souborovému systému, cache èi jiným typùm úlo¾i¹». Zapouzdøuje tak datovou logiku frameworku. Existují rùzná øe¹ení vrstvy Model. Napøíklad ORM, neboli Object Relations Mappping, kterém jsou entity se svými atributy a vztahy mapovány podle relaèní databáze. Dal¹í mo¾ností je Active Record, neboli aktivní záznam tabulky, který se do databáze sám ukládá, naèítá èi ma¾e. Dal¹í mo¾ností je Data Mapper, který má za úkol mapovat entitu do databáze a naopak. DAO neboli Data Access Object, Repository èi Table Data Gateway nám umo¾òují pøístup k popsaným øe¹ením. Pro architektury pokroèilých aplikací existuje i mnoho dal¹ích návrhových vzorù a pøístupù k datové vrstvì. Modelová vrstva bývá oznaèována za nejslo¾itìj¹í vrstvu, a právì proto je potøeba dodr¾ovat techniky OOP vèetnì návrhových vzorù pro dal¹í mo¾nou roz¹iøitelnost a pøehlednost. \cite{design-patterns}

View klade dùraz na prezentaèní úroveò, tedy na zabrazení výsledkù u¾ivateli. Zpracovává tak výsledek práce vrstvy Controller nad vrstvou Model a zobrazuje výsledek urèitých operací. Èasto vyu¾ívá nìkterých ¹ablonovacích pøístupù. \cite{design-patterns}

\clearpage

\obrazek
\vlozeps{../images/mvc.png}{0.5}
\endobr{Návrhový vzor MVC a jeho ¾ivotní cyklus}

\sekce{Optimalizace aplikaèní vrstvy}
\label{sec:profiler}
Optimalizace na úrovni aplikaèní vrstvy mù¾e být provádìna nìkolika zpùsoby a pøístupy. Tato èinnost se týká pøevá¾nì programátorù a softwarových in¾enýrù, kteøí mají za úkol vývoj a údr¾bu aplikaèní vrstvy. K tomu, aby se daly identifikovat problematické èásti, které vy¾adují optimalizaci, slou¾í tzv. profilery. Ty mají obecnì za úkol vyprofilovat jednotlivé funkce, metody, procedury, dotazy a pøíkazy, které se v dané vrstvì, ji¾ je profiler urèen, vyskytují. Dále mají za úkol urèit dobu jejich trvání, poèet volání, èas spu¹tìní, závislosti a dal¹í parametry. Profilování, neboli urèení kandidátù pro optimalizaci, je prvním a nejdùle¾itìj¹ím krokem pro optimalizaci aplikaèní vrstvy webové architektury. Dal¹í kroky se týkají pøedev¹ím tìchto oblastí:

\begin{itemize}
\item Výbìr nejoptimálnìj¹ího algoritmu pro danou úlohu
\item Výbìr nejrychlej¹ího MVC frameworku
\item Vytváøení cache souborù aplikace
\item Zpùsob pøekladu a vykonání zdrojových souborù
\item Pøidání dal¹í vrstvy architektury - aplikaèní cache
\end{itemize}

\sekce{Druhy aplikaèních vrstev}
Existuje celá ¹kála rùzných programovacích jazykù a webových serverù pro implementaci aplikace. Ka¾dý z nich má své výhody a nevýhody, svá specifická øe¹ení a pøístupy. Zde je uveden krátký seznam tìch v praxi nejpou¾ívanìj¹ích:

\begin{itemize}
\item Webový server Apache2 s programovacím jazykem PHP
\item Java Servlets, Java Spring Source
\item C\# s technologií .NET
\item Ruby on Rails
\item Python a Django
\item a mnohé dal¹í
\end{itemize}

\sekce{Ajax a webové slu¾by}
Ajax, neboli Asynchronous JavaScript and XML, se dnes stává nedílnou souèástí vývoje webových aplikací. Aplikace tak dostávájí interaktivnìj¹í charakter a obejdou se bez nutnosti znovuzaslání celého po¾adavku webové aplikaci. Celý tento pøístup probíhá nejvíce na stranì klienta. Je pou¾it JavaScript pro programovou implementaci, který má pøístup ke stromu objektù dokumentu zvaného DOM, neboli Document Object Model. V této kapitole je AJAX uveden z toho dùvodu, ¾e pou¾ívá objekt XMLHttpRequest pro komunikaci s aplikaèním serverem. Tyto aplikaèní po¾adavky jsou nazývány webovými slu¾bami pro Ajax. Tyto po¾adavky jsou vykonávány na aplikaèní vrstvì a pøedstavují potenciální zátì¾, která musí být v nìkterých pøípadech optimalizována.\cite{ajax}



% Databaze
\kapitola{Dabázová vrstva}
\label{sec:database}
Úkolem databázové vrstvy ve webové architektuøe je zaji¹»ovat datové slu¾by a uchovávat tak aplikaèní data perzistentní. V oblasti webových architektur se nejèastìji vyskytují relaèní databázové systémy, a proto je tato práce soustøedìna na tento typ databázových systémù. Databázový systém obecnì tvoøí databáze, tedy skupiny strukturovaných homogenních souborù, a SØBD, neboli systém øízení báze dat, jako¾to integrovaný softwarový prostøedek øídící bázi dat.

\sekce{Optimalizace SQL dotazù}
Optimalizace dotazù SQL je nedílnou souèásti procesu práce s databázovým systém v prostøedí vysoké zátì¾e. Je toti¾ dùle¾ité nejenom umìt si získat potøebná data, ale je potøeba zvá¾it i za jakou cenu tato data prostøednictvím databázavého systému získáváme. Hovoøíme-li o webových architekturách s vysokou zátì¾í, je tento proces optimalizace velice dùle¾itý. Ka¾dá operace, ka¾dý dotaz, ka¾dá akce potøebuje ke své realizaci urèité hardwarové a systémové prostøedky. V prostøedí vysoké zátì¾e je dùle¾ité u¹etøit tìchto prostøedkù co nejvíce.

K tomu, abychom mohli vùbec pøistoupit k optimalizaci SQL dotazù, je potøeba urèit a identifikovat, které tyto dotazy jsou opravdu nároèné na prostøedky a èas, neboli mají vysokou cenu. K tomu slou¾í tzv profilery (viz. kapitola \ref{sec:profiler}). Profilery mohou být urèeny pro aplikaèní vrstvu, kde profilují nejenom zdrojové kódy aplikace, ale samozøejmì i databázové dotazy, které jsou z této aplikaèní úrovnì spu¹tìny. Tímto zpùsobem je mo¾né získat pøehled v¹ech operací, které probíhají na aplikaèní i databázové vrstvì, ponìvad¾ tyto vrstvy spolu úzce souvisí a spolupracují. Dal¹í mo¾ností je pou¾ít profiler urèený pøímo pro databázovou vrstvu. Takový profiler pak profiluje pouze databázovou vrstvu, jednotlivé databázové dotazy, jejich cenu, dobu trvání, a jiné dal¹í statistiky.

Ka¾dý SQL dotaz má nìjaký svùj exekuèní plán. Databázový systém po obdr¾ení SQL dotazu vybírá z nìkolika mo¾ných exekuèních plánù ten nejvýhodnìj¹í, který je po té v databázi proveden. Pøi výbìru exekuèního plánu je brán v potaz výbìr indexu a zpùsob skenu tabulek, vybraná spojení, aj. Exukuèní plán je mo¾né zobrazovat v mnoha databázových systémech pomocí SQL dotazu EXPLAIN, a identifikovat tak místa exekuèního plánu, která mohou být kandidátem pro optimalizaci.\cite{optimalizace-sql}

Pro optimalizaci SQL dotazù je mo¾né urèit nìkolik základních oblastí, na které se lze zamìøit pøi konkrétní optimalizaci urèitého SQL dotazu:

\begin{itemize}
\item Normalizovaný databázový návrh
\item Vnoøené SQL dotazy
\item Indexace, výbìr indexu a zpùsob prohledávání
\item Výbìr druhu a poøadí spojení
\item Zpùsob pou¾ívání podmínek, klauzulí a operátorù
\end{itemize}

\sekce{Indexace}
Indexace je dùle¾itá a nejefektivnìj¹í optimalizace dotazù SQL. Pøi prùchodu dat tabulkou má databáze na výbìr nìkolik mo¾ností prohledání. První mo¾ností je prohledat v¹echny øádky tabulky podle SQL podmínek. To je nazýváno obecnì Full Table Scan, nebo také Sequence Scan, neboli sekvenèní prohledávání. Dal¹í mo¾ností je pu¾ití nìkterého z indexù pro pøístup k hodnotám namapovaných na jejich ROWID, které ukazuje na fyzické ulo¾ení. Toto prohledání bývá nazýváno Index Range Scan, nebo jen obecnì Index Scan, neboli indexaèní prohledávání. Samozøejmì prohledávání tabulek pomocí indexace je výraznì rychlej¹í, a tím pádem dùle¾ité pro opimalizaci SQL. \cite{optimalizace-sql}

Indexy jsou fyzicky i logicky ulo¾eny v asociativních tabulkách, a díky tomu i oddìleny od datových tabulek. Èili pøi smazání indexù se datové tabulky nesma¾ou ani nijak nezmìní. Pouze se mù¾e zpomalit pøístup k datùm, který byl rychlej¹í díky tìmto indexùm. Tabulky s indexy jsou samozøejmì ulo¾eny na disku, ponìvad¾ jejich velikost je obrovská a neve¹ly by se do operaèní pamìti RAM, i kdy¾ pøístup k ní je daleko rychlej¹í. Proto je potøeba volit nìjaký vhodný algoritmus prohledání a pøístupu k indexùm ulo¾eným na disku. Od zvoleného algoritmu se odvyjí i název a druh pou¾ívaných indexù. V ka¾dém databázovém systému samozøejmì naleznete nìkteré typické a nìkteré atypické druhy indexù. \cite{optimalizace-sql} Zde je krátký výbìr mo¾ných indexù:

\begin{itemize}
\item B-tree - pro pøístup pomocí Root-Node-List
\item Bitmap - pro výètové sloupce
\item R-tree - typ indexu optimalizovaný pro geometrická data.
\item GiST - zobecnìný vyhledávací strom
\item a dal¹í
\end{itemize}


\sekce{Partitioning}
Partitioning, který je obèas do èe¹tiny pøekládán jako segmentace, pøípadnì jako ¹kálování, slou¾í v relaèních databázových systémech k rozdìlování tabulek a indexù do men¹ích èástí a komponent. Díky tomu je pak èinnost databáze rychlej¹í a snaz¹í. Pøi této segmentaci tak mù¾e dojít k rozdìlení tabulek na více pevných diskù èi serverù. Tyto segmenty jsou na sobì nezávisle, ale pøitom je k nim mo¾né pøistupovat pøes tabulku, pro kterou byla segmentace vytvoøena. Databázová tabulka a její vlastnosti, jako napøíklad referenèní integrita nebo ¾ádná redundance, jsou stále zachovány a fungují pøes v¹echny její segmenty. Dokonce i kdy¾ dojde k selhání èi výpadku jednoho ze segmentù, ostatní jsou stále pøístupné a je mo¾né s nimi pracovat. Partitioning je mo¾né provádìt na nìkolika úrovních a podle rùzných klíèù. U segmentovaných tabulek je dùle¾ité rozmyslet si jakou strategii zvolit. 

Pøi vertikální segmentaci dojde k segmentaci podle definovaných sloupcù databázové tabulky. Klíèem pøi tomto rozdìlení je urèení sloupeèkù, které se nepou¾ívají ve where klauzuli, nebo jsou prázdné èi zøídka pou¾ívané. 

Èastìji pou¾íváným pøístupem je horizontální segmentace tabulek, èili segmentace podle øádkù. Zde se segmentují øádky, podle urèité hodnoty databázového sloupce. O tom, do jakého segmentu bude øádek tabulky vlo¾en, rozhoduje urèitý interval, hodnota výètu nebo konkrétní funkce.

Dal¹í mo¾nost je aplikaèní úroveò segmentace, která se zøídka objevuje v souvislosti s Partitioning. Nejedná se toti¾ o segmentaci urèité databázové tabulky, ale o segmentaci databáze. Èást tabulek je umístìna na jednom serveru, èást na dal¹ím serveru, a tak dále.

Partitioning je dùle¾itým nástrojem pøi optimalizaci databázové vrstvy v architektuøe webových systémù v prostøedí vysoké zátì¾e. Dá se toti¾ pøedpokládat, ¾e se zvìt¹ující se zátì¾í roste i poèet záznamù tabulek, a tak se doba pøístupu zvìt¹uje a prostøedky se zatì¾ují je¹tì víc. Tyto problémy doká¾e vyøe¹it partitiong.
\cite{partitioning-db}

\sekce{Replikace}
Replikací rozumíme technologii, která umo¾òuje nasadit více databázových serverù v rámci jedné databáze. Jedná se tak o sdílení dat mezi více hardwarovými, softwarovými a jinými prostøedky a jejich pøenositelnost. Úèelem replikace je dosáhnout vysoké dostupnosti databázového systému a ¹kálování výkonu pro optimalizaci v prostøedí vysoké zátì¾e. Obecnì existují dvì základní varianty databázových replikací, od kterých se odvyjí jejich dal¹í vyu¾ití. Samozøejmì v závislosti na konkrétním databázovém systému pak existují dal¹í èlenìní a nastavení. 

Replikace varianty master-slave je podporována ve vìt¹inì databázových systémù. Jedná se o jednodu¹¹í tzv. jednosmìrnou replikaci. V této variantì je urèen autonomní prvek, jedna replikace, která akceptuje a zpracovává po¾adavky na zmìny. Takováto replikace nese název master. Prvek s názvem slave je vìrnou kopií autonomního prvku master. Slou¾í pouze ke ètení a mù¾e jich existovat více pro jeden master. Jakmile master obdr¾í a zpracuje po¾adavek na zmìnu, tak jej po dokonèení pøenese na ostatní slave replikace.

Replikace typu master-master bývá oznaèována jako obousmìrná. To znamená, ¾e jsou v rámci jednoho databázového systému minimálnì dvì replikace typu master, které akceptují v¹echny druhy po¾adavkù na zmìny i ètení a pøená¹í je vzájemnì mezi sebou. Z této vlastnosti vyplývá, ¾e mù¾e dojít ke kolizím, napøíklad pokud dvì replikace master zapisují do stejné tabulky. Takové kolize jsou nevyhnutelné a je potøeba umìt je øe¹it.

Zpùsob pøenosu mezi jednotlivými replikacemi mù¾e být synchronní èi asynchronní. U synchronního pøenosu se èeká a¾ se zmìny provedou na v¹ech ostatních replikacích. Tento proces je èasovì nároèný, ov¹em na druhou stranu je celý databázový systém konzistentní jako celek. U asynchronního pøenosu se neèeká na dokonèení pøenosu mezi ostatními replikacemi. Díky tomu je celý databázový systém rychlej¹í, ov¹em mù¾e dojít k nekonzistenci, kdy na ostatní replikace je¹tì nejsou pøenesena v¹echna data.

Administrace, nástroje a konfigurace replikací jsou zabudované v témìø ka¾dém databázovém systému. Je dùle¾ité poznamenat, ¾e tyto nástroje nejsou mnohdy dostaèující øe¹ení pro architektury v prostøedí vysoké zátì¾e, a je proto nutné pou¾ívání jiných doplòkových nástrojù. Také je více ne¾ dùle¾ité øíct, ¾e v prostøedí vysoké zátì¾e se webová architektura bez databázových replikací jen tì¾ko obejde.\cite{replikace}

\sekce{Druhy relaèních databází}
V dne¹ní dobì existuje nìkolik druhù relaèních databázových systémù. Ka¾dý z nich má své klady a zápory, ov¹em princip a zpùsob práce tìchto databází je v základu podobný. Zde je uveden pøehled tìch v praxi nejbì¾nìj¹ích:

\begin{itemize}
\item Oracle
\item MySQL
\item PostgreSQL
\item MSSQL
\item Firebird
\item a mnoho dal¹ích
\end{itemize}



% Web cache
\kapitola{Webové cache}
Webové cache jsou dùle¾itou vrstvou pro roz¹íøení výchozí tøívrstvé architektury. Jak u¾ vyplývá z názvu cache, jedná se o vyrovnávací pamì», její¾ hlavní úèel je zrychlit odpovìï webové aplikace na po¾adavek klienta. Zároveò je dùle¾ité poznamenat, ¾e nefunkènost, zánik èi pád cache vrstvy nesmí nijak ovlivnit chod apikace, která musí být funkèní i nadále. Úèel této vrstvy je pouze zrychlit pøístup k datùm èi ji¾ jednou interpretovaných odpovìdím webové aplikace.

Webová cache se nachází mezi klientem a aplikaèní vrstvou. Základní komunikace probíhá tak, ¾e klient po¹le HTTP po¾adavek, aplikaèní server ho pøijme a navrátí HTTP odpovìï. Pøi existenci cache vrstvy probíhá komunikace jiným zpùsobem. Klient po¹le HTTP po¾adavek a webová architektura zjistí, zda-li je tento HTTP po¾adavek urèen pro ukládání do cache pamìti. Pokud ano, tak webová architektura zkusí získat odpovìï z cache pamìti. Kdy¾ tuto odpovìï v pamìti nalezne, za¹le ji pøímo klientovi. V opaèném pøípadì je po¾adavek poslán do aplikaèní vrstvy architektury, která jej zpracuje, vytvoøí odpovìï kterou ulo¾í do cache pamìti a po¹le klientovi. Pøi pøí¹tím stejném po¾adavku bude odpovìï vrácena z pamìti cache. Dojde-li ke zmìnì dat, která jsou ulo¾ena v cache pamìti, dojde k invalidaci ulo¾ených dat v cache pamìti a celý proces zaène od zaèátku s novým HTTP po¾adavkem.

Pro webové architektury v prostøedí vysoké zátì¾e je tato vrstva nevyhnutelná. Odpovìdi z cache vrstvy jsou daleko rychlej¹í, dokonce a¾ mnohonásobnì, ne¾ odpovìdi z aplikaèní vrstvy. Tato práce se zabývá rùznými druhy cache, výsledky jejich profilování a jejich testováním v prostøedí vysoké zátì¾e.

\obrazek
\vlozeps{../images/cache-process.png}{0.6}
\endobr{Diagram aktivit cache webových systémù}

\sekce{HTTP hlavièky pro ovládání cache}
\label{sec:http-headers}
Komunikace ve webových aplikacích probíhá ve valné vìt¹inì pøípadù na úrovni protokolu HTTP. Ka¾dý HTTP po¾adavek obsahuje HTTP hlavièky, kterými urèuje po¾adavek, klienta a obsahuje èasové razítko. Odpovìï na tento po¾adavek navrací v hlavièkách návratový kód, informace o serveru, èasové razítko, typ obsahu odpovìdi, délku odpovìdi a informace pro pøípadné ukládání do cache pamìti. Právì jednotlivé cache hlavièky jsou dùle¾ité pro nastavení, ukládání a invalidace do proxy cache pamìti nebo do reverzní proxy cache pamìti.

Existují dva základní modely pro urèení práce s cache vrstvou. Prvním je expiraèní model. Tento model urèuje, do kdy je platná HTTP odpovìï, neboli do kdy mù¾e tuto odpovìï cache vrstva ukládat a oznaèovat ji jako platnou a stále èerstvou. Tento model mù¾e být realizován dvìma zpùsoby. Prvním je hlavièka Expires s èasovým razítkem urèující, do kdy je odpovìï platná. Druhým, novìj¹ím a daleko flexibilnìj¹í a konfigurovatelnìj¹í zpùsobem je pou¾ití Cache-Control. Díky tomuto zpùsobu je mo¾né urèit dal¹í parametry, nejenom to, do kdy je daná HTTP odpovìï platná. Díky Cache-Control je mo¾né urèit, zda-li je odpovìï urèena jen pro sdílené cache (proxy cache), nebo jen pro u¾ivatelské prohlí¾eèové cache, nebo zda-li ji ukládat èi nikoli, atd.\cite{rfc-http}

Druhým modelem je model validaèní. Ten urèuje zpùsob komunikace pro zji¹tìní, zda-li je odpovìï ulo¾ená v cache pamìti stále validní. Základem je, ¾e cache, která má ulo¾enu odpovìï se zeptá, je-li odpovìï stále validní a server odpoví jestli ano èi vrátí novou èerstvou odpovìï. Tento proces lze realizovat opìt dvìma zpùsoby. Tím prvním je urèení tzv. Last-Modified. Pøi prvním po¾adavku cache získá odpovìï s touto hlavièkoku. Odpovìï si ulo¾í a pøi dal¹ím po¾adavku se cache vrstva dotá¾e serveru pomocí hlavièky If-Modified-Since s èasovým razítkem, zda-li je odpovìï stále validní. Server odpoví návratovým kódem 304, který øíká, ¾e nedo¹lo k ¾ádné zmìnì od daného èasového razítka, a nebo vrátí novou èerstvou odpovìï, pokud do¹lo ke zmìnì. Na podobném principu je zalo¾ena i hlavièka Etag neboli Entity tag. Etag je unikátní identifikátor vygenerovaný serverem pro danou HTTP odpovìï. Cache vrstva si pøi prvním po¾adavku ulo¾í odpovìï s tímto Etag. Pøi dal¹ím po¾adavku po¹le na server HTTP po¾adavek s hlavièkou If-None-Match s tímto Etag. Pokud se hodnoty Etag shodují, vrátí aplikaèní server odpovìï s návratovým kódem 304, a nebo celou èerstvou odpovìï.\cite{rfc-http}

Ovládání pomocí HTTP hlavièek slou¾í hlavnì k statickému obsahu. Pro tento úèel je pak dobré zvá¾it jestli je lep¹í odpovìdi mìnit v nìjakých èasových intervalech a pou¾ívat tak expiraèní model, èi jestli se vyplatí nasazovat model validaèní, který s sebou nese slo¾itìj¹í administraci.\\
\clearpage
Pøíklad HTTP hlavièek pro HTTP odpovìï:
\begin{scriptsize}
\begin{verbatim}
HTTP/1.1 200 OK
Date: Mon, 23 May 2005 22:38:34 GMT
Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)
Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
Etag: "3f80f-1b6-3e1cb03b"
Accept-Ranges:  none
Content-Length: 438
Connection: close
Content-Type: text/html; charset=UTF-8
\end{verbatim}
\end{scriptsize}

\sekce{Druhy cache}
Ve webových architekturách existuje nìkolik druhù cache vrstev. Jejich èlenìní se odvyjí od jejich úèelu, pozici v architektuøe a typu ukládaných dat. Tyto atributy mezi sebou úzce souvisí. Základním èlenìním mù¾e být jejich pozice z pohledu internetu, a to dìlení na klientskou a serverovou èást. Za klientskou èást pova¾ujeme cache systém u¾ivatelova prohlí¾eèe èi systémovìj¹í proxy cache. Na stranì serveru se vyskytují reverse proxy cache èi aplikaèní distribuované cache.

\obrazek
\vlozeps{../images/cache-types.png}{0.5}
\endobr{Druhy cache ve webové architektuøe}

\podsekce{Proxy cache a cache prohlí¾eèe}
Tyto druhy cache se týkají klientské èásti webové architektury, neboli èásti pøed internetem. Znamená to tedy, ¾e odpovìï na klientùv po¾adavek je vrácena z cache pamìti lokální sítì, a tento po¾adavek vùbec nevstoupí do sítì internet na vzdálený dotazovaný server. Tyto cache vrstvy zde nejsou jen pro to, aby zrychlily odevzvu na po¾adavek, ale také aby zmen¹ily odchozí komunikaci z lokální sítì. A to z toho dùvodu, aby byla ¹íøka pásma pøístupná i jiným slu¾bám a u¹etøily se prostøedky na odchozí komunikaci.

V dne¹ních moderních prohlí¾eèích je práce s cache pamìtí podporována. Cache prohlí¾eèe mù¾e nastavovat, konfigurovat, èi vymazat pouze u¾ivatel, neboli klient sám. Tato pamì» ukládá hlavnì statický obsah, napøíklad obrázky, CSS soubory èi JS soubory. Cache pamì» najde své uplatnìní, napøíklad kdy¾ jsou u¾ivatelovy po¾adavky smìøovány jedné webové aplikaci se stejným vzhledem, rozhranním nebo èástí funkcionalit. Takováto data mohou být ukládána do cache pamìti na dlouhou dobu, a proto musí aplikace dbát na to, aby byla tato data z cache promazávána tak, jak je opravdu potøeba. Jednou z mo¾ností je urèit jinou url adresu pro stejný soubor pomocí tzv. Query string, napøíklad takto:

\begin{scriptsize}
\begin{verbatim}
<link rel="stylesheet" type="text/css" href="style.css?QUERY_STRING" media="all" />
\end{verbatim}
\end{scriptsize}

Proxy cache bývají budovány a instalovány providery a poskytovateli pøipojení k internetu. Jejich zámìr je jednoduchý. Jde o to sní¾it míru odchozí komunikace, nezatì¾ovat tolik ¹íøku pásma a zmen¹it náklady spojené s touto komunikací. Nejbì¾nìj¹ím nastavením tìchto proxy cache pamìtí bývá ukládání a invalidace obsahu v závislosti na HTTP hlavièkách pøijaté odpovìdi. Nainstalujeme-li napøíklad takovouto cache ve firmì èi na nìjakém sídli¹ti s nìkolika desítkami, stovkami, èi dokonce tisíci u¾ivateli, je mo¾né, ¾e èást z nich má ka¾dé ráno stejný po¾adavek na stejný zpravodajský server, tudí¾ mají i stejnou odpovìï. A tak mù¾e být první odpovìï ulo¾ena do cache pamìti a dal¹ím u¾ivatelùm mù¾e být servírována z proxy cache pamìti.\cite{proxy-cache}

\obrazek
\vlozeps{../images/proxy-cache.png}{0.5}
\endobr{Proxy cache ve webové architektuøe}

\podsekce{Reverzní proxy cache}
\label{sec:reverse-proxy}
Reverzní proxy cache, nìkdy oznaèovány jako tzv. Gateway cache, mají podobný systém èinnosti jako proxy cache. Mají za úkol ukládat statický obsah ve formì HTTP odpovìdí a tyto odpovìdi vracet nazpìt tam, odkud pøi¹el jejich po¾adavek. Úkolem je tak pokud mo¾no nepropustit po¾adavek dále na aplikaèní vrstvu, stejnì jako úkolem proxy cache je pokud mo¾no nepropou¹tìt po¾adavek dále do internetu. Rozdíl mezi reverzní proxy cache a proxy cache spoèívá v jejich pozici ve webové architektuøe, a také v tom, kým jsou instalovány. Pozice reverzní proxy cache je na stranì serveru, neboli blí¾e aplikaèní vrstvì architektury, tedy na druhé stranì internetu, ne¾ odkud pøíchází po¾adavky klientù a kde jsou instalovány proxy cache. Reverzní proxy cache jsou instalovány samotnými administrátory a programátory webové aplikace. Jejich úèel tkví v zaji¹tìní rychlej¹í odezvy webové aplikace na HTTP po¾adavky klientù. Reverzní proxy cache jsou nedílnou souèástí webové architektury v prostøedí vysoké zátì¾e a bez jejich existence by jen tì¾ko mohla být webová aplikace spolehlivá a rychlá.\cite{proxy-cache}

\obrazek
\vlozeps{../images/reverse-proxy-cache.png}{0.5}
\endobr{Reverzní proxy cache ve webové architektuøe}

\podsekce{Aplikaèní distribuovaná cache}
Doposud byly popisovány cache pamìti pro ukládání statického obsahu. Ov¹em v praxi se od projektového vedení setkáme s po¾adavky na dynamické chování aplikace. Jako pøíklad mù¾e poslou¾it opìt situace s komentáøi, kdy jeden u¾ivatel vlo¾í komentáø k nìkterému z èlánkù. Tento komentáø se musí okam¾itì objevit v seznamu komentáøù k èlánku. V pøípadì statického obsahu, který se mìní pouze v urèitých intervalech, mù¾e u¾ivatel nabýt dojmu, ¾e se jeho komentáø nepodaøilo vlo¾it a zkusí ho vlo¾it znovu. Takové chování aplikace urèitì není v souladu s dobrým chováním interakce mezi u¾ivatelem a aplikací. K tomu, aby se dala data ukládat do cache a aplikace byla stále dynamická, slou¾í tzv. aplikaèní distribuovaná cache. HTTP po¾adavek je rozdistribuován mezi men¹í po¾adavky a mezi cache pamìti.

Jak u¾ vyplývá z názvu této cache, o manipulaci s touto cache pamìtí se stará aplikaèní vrstva. Standardnì se ukládají do cache pamìti ta data, k nim¾ je dlouhá doba pøístupu, obvykle data z databáze. Úèelem je tedy u¹etøit spojení a dotazy na databází. Jeden HTTP po¾adavek s konkrétní url je èasto rozdìlen na nìkolik po¾adavkù do databáze, v závislosti na tom, o jaká data se jedná. Napøíklad v rámci jedné HTTP stránky mù¾e být databáze dotázána o po¾adovaný èlánek a seznam komentáøù pod èlánkem. Databáze tak obdr¾í dva SQL dotazy, na které vrátí pøíslu¹ná data z databáze. Aby se pøí¹tì aplikace nemusela na tato data dotazovat, ulo¾í si je do aplikaèní cache pamìti.

Pøi ukládání takových dat do cache pamìti aplikaèní vrstva urèuje, jak a kam mají být data ulo¾ena, a kdy a za jakých podmínek mají být invalidována. Pøi aplikaci této cache vrsty dochází k propu¹tìní po¾adavku na aplikaèní servery, co¾ znamená vìt¹í zátì¾ aplikaèní vrstvy. Reverzní proxy cache jsou v tomto smìru nepou¾itelné, slou¾í pouze pro statický obsah a v¹echny po¾adavky propou¹tí dále na aplikaèní vrstvu.

Pøi práci s aplikaèní distribuovanou cache je dùle¾ité si uvìdomit nìkolik základních pravidel. Prvním pravidlem je ukládat data do cache pamìti co nejmen¹í. Úèelem je distribuovat jednotlivá data v rùzných kontextech. Dále je dùle¾ité ukládat data znovuzkonstruovatelná. Je dùle¾ité umìt z cache pamìti pøeèíst to, co do ní bylo ulo¾eno. Nejlep¹í je ukládat data serializovaná. Dále je nutno dodr¾et jednoznaèný a jasnì definovaný klíè èi jmenný prostor pro tato data. Aplikace toti¾ musí vìdìt, kde a jak se ptát na data. Dal¹ím pravidlem je peèlivá a kompletní invalidace dat v cache pamìti. Právì invalidace je nejvìt¹í problém pro práci s cache pamìtí. Stejná data mohou být interpretována v rùzném kontextu. Napøíklad pøi vlo¾ení nového èlánku se zmìní data pro seznam v¹ech nejnovìj¹ích èlánkù, a také data pro seznam nejnovìj¹ích èlánkù v dané rubrice. Vzhledem k tomu, ¾e aplikace implementuje dynamické chování, musí být tento èlánek vidìt ihned po vlo¾ení ve v¹ech zmínìných interpretacích. Èili musí dojít k invalidaci v¹ech závislostí. Tento problém je oznaèován jako invalidaèní kaskády, a proto je dùle¾ité konstruovat aplikaci tak, aby se tìmto kaskádám vyhýbala co nejvíce nebo s nimi musí vývojáø aplikace poèítat u¾ pøí návrhu aplikaèní distribuované cache vrstvy.

\obrazek
\vlozeps{../images/application-distributed-cache.png}{0.5}
\endobr{Aplikaèní distribuovaná cache ve webové architektuøe}


\kapitola{CDN}
Vrstva CDN neboli Content Delivery Network je dùle¾itou souèástí webové architektury v prostøedí vysoké zátì¾e. Jejím úkolem je rozdìlit zátì¾ webové architektury mezi více uzlù. Jedná se o nìkolik serverù, které mají za úkol klientùm pøedávat vesmìs statický obsah ve formì multimédií, stream videa èi softwarových aktualizací. 

CDN mají obvykle jeden centrální prvek, který rozhoduje o tom, na který z CDN uzlù se po¾adavek pøesmìruje. Rozhodování mù¾e probíhat v závislosti na spoustì ukazatelù a zále¾í u¾ na konkrétním vyu¾ití CDN. Centrální prvky se mohou rozhodovat napøíklad na základì geografického rozdìlení. Centrálním prvkem je DNS server, který má pøehled o kompletní topologii sítì CDN. Díky tomu má pøehled o tom, který ze serverù se kde nachází. Dal¹ím ukazatelem pro centrální prvek mù¾e být stav serverù, jejich vytí¾ení operaèní pamìti RAM a procesoru CPU, stav odesílaných paketù na sí»ových kartách, stav cache pamìtí apod. 

Existují komerèní i open source CDN sítì, vìt¹í spoleènosti pak mívají vlastní øe¹ení. Mezi CDN se objevují i mo¾nosti pro servírování dynamického obsahu, ov¹em primární úèel by mìl být obsah statický. CDN najdou významné uplatnìní tam, kde dochází k pøenosùm velkých souborù, které se u¾ nijak nemìní, a nebo se mìní ve velkých intervalech.\cite{cdn}

\obrazek
\vlozeps{../images/cdn.png}{0.5}
\endobr{Ukázka komunikace klienta s CDN sítí}


% Virtualizace
\kapitola{Virtualizace}
Virtualizace je moderní pojem, který umo¾òuje lep¹í ¹kálovatelnost aplikace a mo¾nost práce s jednotlivými vrstvami webové aplikace a jejími servery. V dne¹ní dobì se nejvíce hovoøí o tzv. virtualizaci platforem, co¾ znamená provozování více virtuálních poèítaèù s vlastním operaèním systémem na jednom fyzickém poèítaèi. Takto virtualizované poèítaèe vèetnì operaèních systémù a aplikací jsou od sebe navzájem izolovány. 

Pøíklady profesionálních nástrojù pro virtualizaci poèítaèù jsou VMWare, Hyper-V a nebo tøeba Citrix Xen Server. Základem virtualizace je fyzický server, který je pod správou vrstvy hypervizor, která øídí pøístup k fyzickým zdrojùm a rozhraním. Takto pøípravený fyzický server se nazývá host. Nìkolik hostù mù¾e být spravováno v jedné skupinì nazývané cluster, která má své zdroje. To v¹e je obvykle spravováno centralním serverem pomocí desktopového klienta èi webového rozhraní.

Virtualizace pøíná¹í spoustu výhod. Jednou z nich je elastiènost zdrojù. Jakmile se toti¾ nìkterý z virtualizovaných serverù jeví jako velice vytí¾ený, je mo¾né mu bìhem pár vteøin pøidat chybìjící prostøedky. Stejnì tak je mo¾né tyto prostøedky ubrat u serverù, které jej nevyu¾ijí.

Pro webové architektury je tou nejvìt¹í výhodou konsolidace serverù, neboli provozování vìt¹ího poètu virtualizovaných serverù na men¹ím poètu serveru fyzických. Tohoto øe¹ení se hodnì vyu¾ívá ve webových architekturách. Vzhledem k nároènosti jednotlivých vrstev webové architektury se v dne¹ních dnech pou¾ívá pøístupu s více virtualizovanými servery, které mají mnohdy jediný úèel. Napøíklad jeden server pro datábázi, dal¹í pro webový server, mailový server, cache servery, apod.

Dal¹í výhodou mù¾e být redukce hardware, el. energie, prostoru a dal¹ích zdrojù. Bez virtualizace by pøidání dal¹ího fyzického serveru znamenalo nakoupení HW komponent, vytvoøení dal¹ího místa v serverovnì a pøivedení dal¹ího zdroje elektrické energie. Pro virtualizaci nového serveru staèí vyhodnotit stávající vyu¾ití fyzických prostøedkù jinými virtuálními servery, dále zhodnotit rezervy na fyzických serverech, popøípadì dokoupit u¾ jen dílèí komponenty jako napøíklad operaèní pamì» RAM.

Obrovskou výhodou virtualizace je mo¾nost sjednocení vývojového, testovacího a produkèního prostøedí. Díky virtualizaci získáme bìhem pár okam¾ikù vìrnou kopii nìkterého ze serverù. Stejnì tak je mo¾né virtuální server velice rychle pøenést na jiný fyzický server. Dokonce se mù¾e tento pøenos obejít i bez výpadku serveru, pokud jsou ve stejném clusteru.

Virtualizace dnes znamená obrovské ulehèení pro administraci jednotlivých serverù, jejich konfiguraci, roz¹iøitelnost, apod. Dokonce právì vznikající trend s názvem Cloud Computing vychází z virtualizace, hlavnì z jejích modernìj¹ích oblastí. Proto je pro webovou architekturu v prostøedí vysoké zátì¾e dùle¾ité virtualizovat její jednotlivé vrstvy a servery.\cite{virtual}

\clearpage

\obrazek
\vlozeps{../images/virtual.png}{1}
\endobr{Ukázka virtualizovaných systémù v prostøedí na jednom fyzickém serveru}


% Load balancing
\kapitola{Rozlo¾ení zátì¾e}
\label{sec:load-balancing}
Rozlo¾ení zátì¾e, neboli load balancing, se pou¾ívá v momentì, kdy zátì¾ webové architektury pøeroste mo¾nosti a výkonnost nìkterého ze svých serverù. Tím pádem je nutné pøidat dal¹í server, a zajistit tak rovnomìrné rozlo¾ení zátì¾e mezi tyto servery. 

Nejznámìj¹ím zpùsobem rozlo¾ení zátì¾e je tzv. Round Robin DNS. Pøi dotazu klienta na IP adresu cílového serveru, vrátí DNS server náhodný záznam jednoho z nìkolika cílových serverù. Tímto zpùsobem je zátì¾ rozdìlena náhodnì, èili zhruba rovnomìrnì mezi v¹echny servery. Zde nastává problém se sezením mezi aplikací a klientem, tzv. session. Pokud se klient pøipojuje k rùzným serverùm zcela náhodnì, tak není zaruèeno, ¾e bude mít v¾dy stejné sezení s aplikací. Je toti¾ dùle¾ité, aby kdy¾ se napøíklad u¾ivatel pøihlásí do aplikace, do¹lo k ulo¾ení informace o pøihlá¹ení do jeho sezení a pøi zobrazení pøí¹tí stránky se po nìm aplikace nevy¾adovala opìtovné pøihlá¹ení. V takovém pøípadì náhodného pøidìlování koncových serverù je potøeba ukládat tato sezení do spoleèného úlo¾i¹tì pro v¹echny koncové uzly.

Dal¹í mo¾nost je øe¹it rozlo¾ení zátì¾e na úrovní transportní vrstvy. K tomu slou¾í HW load balancery, které rozhodují, na který ze serverù se po¾adavek pøepo¹le dál. Tato profesionální zaøízení se u¾ mohou rozhodnout v závislosti na jiných parametrech jako aktuální poèet dotazù, pøená¹ených dat, vytí¾enosti ¹íøky pásma, zdrojové IP adresy, její geografické polohy, apod. 

Existují i aplikaèní load balancery. Ty najdou své uplatnìní ve webových architekturách. Jedná se o server s bì¾ícím softwarovým load balancerem, který pøijme a zpracuje po¾adavek a rozhodne, kterému z koncových serverù ho pøedá dál. Aplikaèní load balancer by proto nemìl mít problém zajistit klientovi v¾dy stejný koncový server.

Ve webových architekturách v prostøedí vysoké zátì¾e je zcela nevyhnutelné pou¾ití více uzlù, napøíklad více aplikaèních serverù. Vrstva pro rozlo¾ení zátì¾e je tak nedílnou souèástí webové architektury v prostøedí vysoké zátì¾e.

\obrazek
\vlozeps{../images/load-balancing.png}{0.5}
\endobr{Ukázka jednoduchého rozlo¾ení zátì¾e}


% Dalsi vrstvy
\kapitola{Dal¹í vrstvy aplikace}
V prostøedí vysoké zátì¾e je velice dùle¾itá ¹kálovatelnost. Ta vzniká pøidáváním dal¹ích samostatných vrstev, èím¾ se ubírá práce jiným vrstvám. Proto je dobré zamìøit se i na dal¹í vrstvy, dal¹í aplikace, slu¾by a mo¾nosti, které mohou bì¾et samostatnì bez nutnosti re¾ie a zásahu jiných vrstev, a pøítom mohou hodnì odlehèit dal¹ím vrstvám.

Jednu z mo¾ností, jak pøidat dal¹í vrstvy aplikace a odlehèit tak jiným vrstvám, jsou No SQL databáze. Jak u¾ bylo nastínìho v kapitole \ref{sec:database}, jedním z nejvìt¹ích zdrojù zpo¾dìní ve webových architekturách v prostøedí vysoké zátì¾e mohou být databáze. Proto je vhodné kombinovat toto primární úlo¾i¹tì i s jinými mo¾nostmi. No SQL databáze jsou od klasických relaèních databázi odli¹né tím, ¾e nemají ¾ádnou referenèní integritu, pevnou strukturu záznamù, nezabraòují redundanci, pou¾ívají jiný jazyk pro dotazování a jsou volnìj¹í a flexibilnìj¹í. Své uplatnìní naleznou u dat, ve kterých není potøeba uchovávat pevnìj¹í logiku a se kterými není potøeba provádìt slo¾itìj¹í operace. Mohou se hodit i k uchovávání dat k nìkterým statistikám pro analýzy v Business Inteligence.

Vìt¹ina webových aplikací podporuje funkci vyhledávání. A» u¾ se jedná o kompletní prohledávání v¹ech dat aplikace èi pouze o na¹eptávaè, tak je zbyteèné tìmito akcemi zahlcovat databázový èas a prostøedky. Existují toti¾ i jiné mo¾nosti, jiné aplikace, které zastávají funkènost vyhledávání. Tìmto aplikacím èi slu¾bám se pøedávají data k prohledávání, které si samy prohledávají, indexují a vytváøí dal¹í statistiky pro vyhledávání a nezatì¾ují tím aplikaèní èi databázovou vrstvu.

Urèitì existuje celá øada dal¹ích aplikací a slu¾eb, které pomohou vìt¹ímu rozdìlení a ¹kálování aplikace na jiné dal¹í èásti, které doká¾ou fungovat nezávisle na sobì. Nejdùle¾itìj¹í je co nejvíce odlehèovat vrstvám webové architektury v prostøedí vysoké zátì¾e.



% Prakticka cast
\kapitola{Praktická èást s experimenty a výsledky}
Praktická èást je zamìøena na testy a optimalizaci jednotlivých vrstev webové architektury v prostøedí vysoké zátì¾e. V této práci jsou rozebrány jednotlivé vrstvy architektury, se kterými byly provedeny testy a experimenty. Jedná se o aplikaèní vrstvu, databázovou vrstvu, reverzní proxy cache vrstvu a aplikaèní distribuovanou cache vrstvu. Souèástí práce nejsou pouze popis a charakteristika jendotlivých krokù optimalizace, ale i jejich výsledné statistiky a zátì¾ové testy. Hlavní èástí praktické èásti je ov¹em návrh a implementace aplikaèní úrovnì plnì podporující práci s aplikaèní distribuovanou cache. Dále je popsána i výsledná konfigurace a nastavení jednotlivých vrstev architektury. Výsledkem je tedy kompletní pou¾itelná studie øe¹ící problematiku webové architektury v prostøedí vysoké zátì¾e.

% Popis aplikace a nastroju
\sekce{Vrstvy webové architektury}
Webová architektura sestává z klientské vrstvy, reverzní proxy cache vrsrtvy, aplikaèní vrstvy, aplikaèní distribuované cache a databázové vrstvy. Klientská èást je tvoøena jedním u¾ivatelem s operaèním systémem Linux Ubuntu a zátì¾ovým testovacím nástrojem Siege. Reverzní proxy cache vrstva je realizována programem Nginx. Aplikaèní vrstva se skládá z webového serveru Apache2 s programovacím jazykem PHP a s profilovacím nástrojem XHProf. Aplikaèní distribuovaná cache vrstva je tvoøena programem Memcached. Databází je PostgreSQL. V¹echny tyto vrstvy serverové èásti webové architektury jsou vytvoøeny na zvlá¹tních virtualizovaných serverech. Pro reverzní proxy cache a aplikaèní distribuovanou cache byl zvolen jeden server. Ka¾dý ze serverù je virtualizován za pomoci virtualizaèního nástroje VirtualBox. Celá webová architektura je konfigurována v jedné virtuální lokální síti 10.9.0.0/24 se statickým pøidìlením IP adres. Rozhraní pro pøípojení tìchto virtualizovaných serverù do virtuální sítì je realizováno pomocí sí»ových mostù. Vzhledem k tomu, aby bylo mo¾no ukázat velké pomìrové rozdíly v jednotlivých krocích optimalizace pro jednotlivé vrstvy architektury, bylo roznodnuto pro velice slabé hardwarové vybavení jednotlivých serverù. Tyto servery mají 512MB operaèní pamìti RAM a jeden jednojádrový procesor s frekvencí 2GHz.

\obrazek
\vlozeps{../images/nginx-architecture.png}{0.5}
\endobr{Vrstvy implementované webové architektury}

\sekce{Testovací a profilovací nástroje}
Proto, aby mohla být v¹echna tvrzení a závìry øádnì podlo¾ena, a aby bylo mo¾né identifikovat místa nutná pro optimalizaci, jsou potøeba urèité testovací a profilovací nátroje. Pomocí profilovacího nástroje XHProf byly vyprofilovány statistiky pro aplikaèní vrstvu. Byl proveden rozbor exekuèních plánù pro SQL dotazy pro databázovou vrstvu, aby byla vidìt míra jejich optimalizace. Také bylo potøeba vytvoøit prostøedí vysoké zátì¾e a k tomu dopomohl program Siege.

\podsekce{XHProf}
K tomu, aby bylo mo¾né profilovat programovací jazyk PHP, byl vybrán profilovací nástroj XHProf. Tento nástroj byl vyvinut v programovacím jazyce C. Uvolnìn byl pod open-source licencí Apache 2.0. Autorem tohoto profilovacího nástroje je spoleènost Facebook. Tento profilovací nástroj doká¾e vyprofilovat nejenom dobu trvání jednotlivých metod a funkcí, ale i jejich procesorové èi pamì»ové nároky. XHProf je mo¾né provozovat na operaèních systémech Linux, FreeBSD a Mac OS X.

Jeho instalace a konfigurace je jednoduchá a bezproblémová. Staèí si stáhnout instalaèní balíèek s roz¹íøením, zkomipilovat a nainstalovat. Po instalaci je nutné jej zaregistrovat jako roz¹íøení pro PHP v konfiguraèním souboru php.ini. Samotné pou¾ití je pak velice snadné. Na zaèátek PHP skriptu se pøidá zdrojový kód s jeho aktivací a na konci PHP skriptu kód pro jeho deaktivaci.

Výsledkem profilování je pøehledná statistika jednotlivých metod a funkcí ve formátu HTML. V¹echno v pøehledné tabulce, ve které je mo¾né mìnit pohled výsledkù profilování podle specifické metody èi funkce. V tabulce je mo¾né pozorovat èas strávený vykonáváním pouze dané funkce, èas strávený vykonáváním funkcí z ní volané, poèet volání funkce, doba trvání, procesorový èas a pamì»ové nároky. Výsledkem mù¾e být i graf vygenerovaný ze statistik profilování a ze závislostí mezi voláním jednotlivých funkcí.

Tento program je nenároèný a mù¾e být provozován i v ostrém provozu. Výsledky takového profilování jsou dùle¾ité k identifikaci problémových míst k optimalizaci, èili pro webovou architekturu v prostøedí vysoké zátì¾e jsou nevyhnutelné.\cite{xhprof}

\newpage
Pøíklad pou¾ití XHProf profilování:
\begin{scriptsize}
\begin{verbatim}
<?php
// Enable profiling
if (extension_loaded('xhprof')) {
    include_once '/usr/local/lib/php/xhprof_lib/utils/xhprof_lib.php';
    include_once '/usr/local/lib/php/xhprof_lib/utils/xhprof_runs.php';
    xhprof_enable(XHPROF_FLAGS_CPU + XHPROF_FLAGS_MEMORY);
}

// Php code for profiling
...

// Disable profiling
if (extension_loaded('xhprof')) {
    $profiler_namespace = 'myapp';  // namespace for your application
    $xhprof_data = xhprof_disable();
    $xhprof_runs = new XHProfRuns_Default();
    $run_id = $xhprof_runs->save_run($xhprof_data, $profiler_namespace);
}
?>
\end{verbatim}
\end{scriptsize}

\podsekce{Siege}
Vzhledem k tomu, aby mohlo být nasimulováno prostøedí vysoké zátì¾e, byl zvolen nástroj Siege pro zátì¾ové testy. Siege je tedy nástrojem pro testování webových aplikací a jejich doby odezvy v prostøedí vysoké zátì¾e. Tento nástroj má opìt lehkou a pøívìtivou instalaci, nachází se toti¾ v základních instalaèních balíècích pro operaèní systém Linux Debian. Siege je programem spou¹tìným z pøíkazové øádky. Jako ka¾dý program, tak i siege má samozøejmì svùj konfiguraèní soubor, který je dùle¾itý hlavnì pro nastavení maximální provádìcí doby jednotlivých testù.

Volby parametrù tohoto pøíkazového programu jsou velice bohaté, ale pøitom jednoduché pro pochopení a pou¾ití. Základními parametry jsou:

\begin{itemize}
\item c - poèet simulovaných konkurenèních u¾ivatelù
\item d - interval zpo¾dìní mezi jednotlivými u¾ivatelskými po¾adavky
\item r - poèet repetic pro zátì¾ové testy
\end{itemize}

Pro tuto práci byly provádìny zátì¾ové testy simulováním deseti u¾ivatelù, v intervalu od nuly do jedné sekundy ve tøech repeticích. Spu¹tìní vypadá takto:
\begin{scriptsize}
\begin{verbatim}
siege -d1 -c10 -r3 -v http://dp-xskrha.local/hello/Mendelu
\end{verbatim}
\end{scriptsize}


\podsekce{PostgreSQL Explain}
Pro konkrétní analýzu problémových SQL dotazù je potøeba identifikovat a analyzovat jejich exekuèní plán. V databázi PostgreSQL a ve vìt¹inì databázích k tomu slou¾í pøíkaz explain, který takto zobrazí exekuèní plán. V této práci byla analyzována problémová místa pomocí XHProf profilování, ze kterého se zjistilo, ¾e v¹echna ploblémová místa souvisí s dotazy pro databázi. Po této fázi identifikace následovala fáze vysvìtlení pomocí SQL dotazu EXPLAIN.

Pomocí EXPLAIN je mo¾né vysvìtlit v¹echny kroky exekuèního plánu. Je tak mo¾né zjistit jaký zpùsob prohledání byl zvolen, zda-li sekvenèní nebo indexový. Dále je mo¾né zjistit druh spojení, jestli merge join nebo hash join, apod. U jednotlivých krokù exekuèního plánu je zobrazena jejich cena, pøedpokládaný poèet øádkù a pøedpokládaný poèet sloupcù. Tímto zpùsobem je mo¾né identifikovat slabá místa exekuèního plánu a provést mo¾nou úspì¹nou optimalizaci.\\
\\
\\ Ukázka analýzy exekuèního plánu:
\begin{scriptsize}
\begin{verbatim}
explain analyze select * from film f where film_id in (select film_id from film_actor);
                                   QUERY PLAN
--------------------------------------------------------------------------------------------
Hash Join  (cost=117.26..195.78 rows=977 width=390) (actual time=21.067..26.570 rows=997 loops=1)
  Hash Cond: (f.film_id = film_actor.film_id)
  -> Seq Scan on film f  (cost=0.00..65.00 rows=1000 width=390) 
  	     (actual time=0.016..1.699 rows=1000 loops=1)
  -> Hash (cost=105.05..105.05 rows=977 width=2) (actual time=21.029..21.029 rows=997 loops=1)
    -> HashAggregate  (cost=95.28..105.05 rows=977 width=2) 
           (actual time=17.598..19.298 rows=997 loops=1)
       -> Seq Scan on film_actor  (cost=0.00..81.62 rows=5462 width=2) 
              (actual time=0.012..8.019 rows=5462 loops=1)
Total runtime: 28.020 ms
\end{verbatim}
\end{scriptsize}


% APC
\sekce{Aplikaèní vrstva PHP}
V aplikaèní vrstvì byl zvolen pro implementaci programovací jazyk PHP 5.3 bì¾ící na webovém serveru Apache 2.0. Webový server Apache je jedním z nejroz¹íøenìj¹ích a nejpopulárnìj¹ích webových serverù na internetu. Byl implementován v roce 1996 v jazyce C++. Jeho instalace, konfigurace a administrace není nikterak slo¾itá. Je podporován vìt¹inou poskytovalù webového hostingu v základní konfiguraci. Je to volnì pou¾itelný produkt, který obsahuje spoustu rùzných pøídavných módù. Z tìchto dùvodù byl vybrán pro praktickou èást této diplomové práce.

Programovací jazyk PHP se stal jedním z nejpou¾ívanìj¹ích programovacích jazykù pro svoji srozumitelnost, pøenositelnost a jednoduchost. Je to dynamicky typovaný programovací jazyk, èili i z tìchto dùvodù je hodnì ohebný. Plnì podporuje OOP pøístup, èili je mo¾né vy¾ívat tìchto technik vèetnì návrhových vzorù, které jsou pro pokroèilé webové aplikace v prostøedí vysoké zátì¾e velice dùle¾ité. Aplikaèní vrstva samozøejmì podporuje plnì koncept návrhového vzoru MVC vyu¾íváním MVC frameworku Symfony 2.


\podsekce{Optimalizace pomocí APC}
\label{sec:optim-apc}
Programovací jazyk PHP je sice jednoduchý na vývoj, èitelnost a dynamiènosti, ov¹em jeho daò je èasová nároènost pro pøeklad. Tento jazyk je interepretovaný jazyk, èili pøi jeho interpretaci dochází k pøekladu do Opcode PHP kompilátorem. Vzniká tak mezikód, který je po skonèení pøekladu vykonán.

K tomu, aby se nemusel poka¾dé pøekládat stejný script PHP kompilátorem, je mo¾né ho ulo¾it do cache pro mezikód, neboli Opcode Cache. K tomuto úèelu slou¾í APC, neboli Alternative Opcode Cache. APC je roz¹íøením pro PHP vytvoøené pøímo samotnými tvùrci programovacího jazyka PHP. Toto roz¹íøení není vùbec nároèné na intalaci ani konfiguraci. Dokonce je k nìmu mo¾né zprovoznit i webové rozhraní ukazující poèet úspì¹ných èi neúspì¹ných dotazù do cache a jiné dal¹í statistiky. Prostøednictvím APC programového rozhraní se dají do cache pamìti ukládat i jiné dal¹í hodnoty pøímo ze zdrojových kódù. Úlo¾i¹tìm pro APC je operaèní pamì» RAM. Z toho dùvodu je tedy dùle¾ité, aby bì¾el webserver Apache2 stále zapnutý. Pøi restartu webového serveru dojde k invalidaci celé APC cache pamìti.\cite{apc}

Vìt¹ina interpretovaných jazykù je pøekládána do nìjakého mezikódu. Proto se pøi ¾ádné zmìnì zdrojových kódù dá vyu¾ít u¾ jednou zkompilovaných výsledkù. Tato forma recyklace zkompilovaného mezikódu doká¾e pøinést velké výsledky pøi optimalizaci. U APC jsou tyto výsledky více ne¾ viditelné.

\podsekce{Dosa¾ené výsledky}
Pro dosa¾ení výsledkù optimalizace aplikaèní vrstvy bylo vygenerováno prostøedí vysoké zátì¾e deseti konkurenèních u¾ivatelù s intervalem po¾adavkù do jedné sekundy ve tøech repeticích. Na aplikaèním serveru tak vzniklo deset vláken Apache2 s PHP 5.3 pro ka¾dého z u¾ivatelù a celý procesorový výkon byl tak rozdìlen rovnomìrnì mezi jednotlivé vlákna po deseti procentech. Vytí¾ení procesoru aplikaèního serveru tak dosahovalo sta procent, èili maximálního vytí¾ení. Toto prostøedí jsem nasimuloval jak pro neoptimalizované prostøedí bez APC, tak i pro optimalizovné prostøedí s APC. Pro ka¾dý po¾adavek docházelo ke zpracování celého MVC frameworku, èili ke zpracování mnoho funkcí, tøíd a metod. Z XHProf profilování jsem vyprofiloval výsledky pro jeden po¾adavek jak pro situaci s pou¾itím APC, tak i bez pou¾ití APC. Výsledky tohoto profilování jsou takovéto:

\begin{itemize}
\item neoptimalované - bez APC - 1,3s
\item optimalizované - s APC - 0,4s
\end{itemize}

Z výsledku vyplývá, ¾e pøi optimalizaci aplikaèní vrstvy pomocí APC do¹lo k zrychlení pøekladu a provedení PHP skriptù o více ne¾ padesát procent, a to jak pøi jediném po¾adavku, tak i v prostøedí vysoké zátì¾e. Takovýto fakt se dá urèitì oznaèit úspì¹nou optimalizací. Alternativou mù¾e být pou¾ití pøístupu s webovým serverem Lighttpd a s cache pamìtí pro mezikód eAccelerator. Výsledky by mìli být hodnì podobné. V dne¹ních dnech se objevují a publikují zprávy o uvolnìní HIP-HOP pro PHP od spoleènosti Facebook. HIP-HOP pou¾ívá úplnì jiného pøístupu pro zrychlení bìhu PHP scriptù. Tato varianta je dnes je¹tì hodnì èerstvá a ne tak provìøená, ov¹em pøedstavuje dal¹í mo¾nosti pro optimalizaci aplikaèní vrstvy s PHP v prostøedí vysoké zátì¾e v budoucích dnech.

\obrazek
\vlozeps{../images/graph-apc.png}{0.4}
\endobr{Graf s výsledky porovnání doby trvání jednotlivých po¾adavkù pro repetice s pou¾itím a bez pou¾ití APC}

\obrazek
\vlozeps{../images/top-apc.png}{0.4}
\endobr{Výpis systémových procesù aplikaèního serveru s APC v prostøedí vysoké zátì¾e}

\clearpage

\obrazek
\vlozeps{../images/app-architecture.png}{0.5}
\endobr{Výsledné zapojení webové architektury s aplikaèní vrstvou a APC}



% Databaze
\sekce{Databázová vrstva}
Databázová vrstva je dùle¾itou a nezbytnou souèástí webové architektury. Její úloha je perzistence dat pomocí databázového systému. Ov¹em pøístup k datùm mù¾e být nìkdy velice zdlouhavý, a¾ v øádech nìkolika minut a hodin. V prostøedí vysoké zátì¾e dochází obvykle k obrovskému rùstu dat a je potøeba optimalizovat databázovou vrstvu tak, aby jejich doba pøístupu byla co nejkrat¹í.

V této práci byla vytvoøena databáze nad databázovým systémem PostgreSQL. Tento systém je volnì dostupný a najde velké uplatnìní právì ve webových architekturách. Podporuje v¹echny standartní databázové operace a pøístupy a je oblíben pro svoji spolehlivost.

Databáze modelované aplikace obsahuje záznamy v øádech miliónù øádkù. To z toho dùvodu, aby bylo nasimulováno prostøedí vysoké zátì¾e i s velkou databází. Datové záznamy byly pro potøeby mé práce vygenerovány a nepøedstavují ¾ádnou paralelu s reálnými daty.

\podsekce{Optimalizace databáze}
\label{sec:optim-database}
Pøed samotnou optimalizací databázové vrstvy nebyla databáze ¾ádným zpùsobem optimalizována, a» u¾ za pomocí indexace, optimalizace SQL dotazù, segmentováním èi vytvoøením replikací. Pøístup k datùm v databázi tak nebyl ¾ádným zpùsobem efektivní. Jednalo se o znovu se opakující SQL dotazy a dokonce místo jednoho SQL dotazu se objevovalo více SQL dotazù pro zji¹tìní stejné informaèní hodnoty. Bylo tak rozhodnuto pro aplikaci optimalizace databázové vrstvy pomocí optimalizace SQL dotazù.

Pøí procesu optimalizace se napøed urèily problematické SQL dotazy pomocí XHProf profilování. Z tohoto procesu bylo zji¹tìno, které sql dotazy je potøeba zoptimalizovat. Dal¹ím krokem byl rozbor jejich exekuèního plánu, vyhledání øe¹ení a jeho aplikace. Øe¹ením optimalizace nìkterých z exukuèních plánù byla indexace pøíslu¹ných sloupcù pro nahrazení sekvenèního prohledání za indexové prohledání. Zde je ukázka rozboru neoptimalizovaného exekuèního plánu se sekvenèním prohledáním:

\begin{scriptsize}
\begin{verbatim}
SELECT * FROM dp_comment WHERE article_id = 15 ORDER BY create_time DESC;
-------------------------------------------------------------------------
Sort  (cost=121201.07..121201.08 rows=3 width=540) (actual time=16300.440..16300.444 rows=3 loops=1)
  Sort Key: create_time
  Sort Method:  quicksort  Memory: 20kB
  ->  Seq Scan on dp_comment  (cost=0.00..121201.05 rows=3 width=540) 
          (actual time=13.531..16300.393 rows=3 loops=1)
        Filter: (article_id = 15)
Total runtime: 16300.526 ms
\end{verbatim}
\end{scriptsize}

Po optimalizaci je vidìt, ¾e sekvenèní prohledání bylo odstranìno a nahrazeno indexovým prohledáním, které je daleko efektivnìj¹í:

\begin{scriptsize}
\begin{verbatim}
SELECT * FROM dp_comment WHERE article_id = 15 ORDER BY create_time DESC;
-------------------------------------------------------------------------
Sort  (cost=8.47..8.48 rows=3 width=540) (actual time=0.119..0.134 rows=4 loops=1)
  Sort Key: create_time
  Sort Method:  quicksort  Memory: 21kB
  ->  Index Scan using dp_comment_article_id_fk_i on dp_comment  (cost=0.00..8.45 rows=3 width=540) 
          (actual time=0.043..0.068 rows=4 loops=1)
        Index Cond: (article_id = 1441)
Total runtime: 0.303 ms
\end{verbatim}
\end{scriptsize}

\podsekce{Dosa¾ené výsledky}
Pøi optimalizaci SQL dotazù byly dùkladnì prozkoumány exekuèní plány jednotlivých dlouhotrvajících SQL dotazù. Na spoustì místech byly øe¹itelné pomocí indexace. Aby byly tyto kroky potvrzeny i v prostøedí vysoké zátì¾e, bylo nasimulováno prostøedí vysoké zátì¾e opìt pomocí programu Siege, který vytvoøil deset konkurenèních u¾ivatelù s intervalem po¾adavku do jedné sekundy ve tøech repeticích. Test probìhl samozøejmì pøed optimalizací i po optimalizaci.

Z výsledkù experimentu vyplývá, ¾e SQL dotazy, které trvaly nìkolik øádù sekund byly zoptimalizovány a¾ pod dobu jedné sekundy. Z grafu v prostøedí vysoké zátì¾e je vidìt, ¾e pøed optimalizací byla maximální doba jednoho po¾adavku a¾ 420 sekund. Celý proces byl hodnì nestabilní a kolísavý. Po optimalizaci je viditelné ustálení èinnosti databázového systému a zmen¹ení doby odezvy. Zrychlení je vidìt a¾ o více ne¾ padesát procent. Dal¹ími budoucími øe¹eními, která se by se dala aplikovat, mohou být segmentace èi replikace databázového systému. Samotná optimalizace SQL dotazù øe¹í urèité problémy, ov¹em databáze mù¾e pøerùst a¾ do takových rozmìrù, kdy je potøeba sáhnout k tìmto dal¹ím øe¹ením.

Databázová vrstva bývá velice èasto nejvìt¹ím zdrojem zpomalení. Dotazy na tuto vrstvu jsou nejnároènìj¹í ze v¹ech procesù v celé webové architektuøe. Proto je velice dùle¾ité tento proces nepodceòovat a vìnovat tomu patøièné prostøedky.

\obrazek
\vlozeps{../images/graph-db.png}{0.4}
\endobr{Graf s výsledky porovnání doby trvání jednotlivých po¾adavkù pro repetice pøed a po optimalizaci SQL dotazù}

\obrazek
\vlozeps{../images/xhprof-model-db-no-optim.png}{0.4}
\endobr{XHProf profilování aplikaèního modelu databázových dotazù pøed optimalizací SQL dotazù}

\clearpage

\obrazek
\vlozeps{../images/xhprof-model-db-optim.png}{0.4}
\endobr{XHProf profilování aplikaèního modelu databázových dotazù po optimalizaci SQL dotazù}


\obrazek
\vlozeps{../images/database-architecture.png}{0.5}
\endobr{Výsledné zapojení webové architektury s optimalizovanou databázovou vrstvou}


% Memcached
\sekce{Aplikaèní distribuovaná cache}
\label{sec:memcached}
Úkolem aplikaèní distribuované cache je ukládat jednou dotazovaná data do cache pamìti a u¹etøit tak SQL dotazy do databáze, které mohou být velice nároèné. Zároveò ponechává webovou aplikaci dynamickou. Celý tento proces je øízen aplikací a její logikou, a tak je potøeba u¾ v návrhu poèítat s existencí dal¹ího typu úlo¾i¹tì, s pøístupem k tomuto úlo¾i¹ti a s invalidací neplatných dat. Pøi pou¾ití aplikaèní distribuované cache vrstvy se kladou velké systémové a výpoèetní nároky na aplikaèní vrstvu. Jejím úkolem u¾ tak není jen vykonávat zdrojový kód PHP skriptù a práce s databází, ale navíc i øízení celé logiky aplikaèní distribuované cache. V této práci jsou uvedeny výsledky, které tato tvrzení dokládají.

\podsekce{Optimalizace aplikace pomocí Memcached}
Ve této práci byla zvolena aplikaèní distribuovaná cache s názvem Memcached. Memcached obsahuje rozhraní pro práci v rùzných programovacích jazycích, napøíklad v Java, Ruby On Rails, .NET, apod. Somozøejmì obsahuje i rozhraní pro programovací jazyk PHP, pou¾itého v mé studii. PHP rozhraní pro Memcached je souèástí doplòkových roz¹íøení pro PHP, èili instalace tohoto rozhraní je rychlá a bezproblémová. Vzhledem k bohaté podpoøe rùzných programovacích jazykù, je mo¾né pou¾ít návrh, pøístup a výsledky této studie aplikaèní distribuované cache Memcached i pro webové architektury implementované v jiných programovacích jazycích ne¾ jen PHP.

Memcached je volnì ¹íøitelným software s vysokou rychlostí a stabilitou. Své uplatnìní najde v prostøedích vysoké zátì¾e, kde doká¾e rapidnì sní¾it dobu pøístupu k datùm a zachovává aplikaci dynamickou. Memcached byla vyvinuta a implentována v jazyce C pro Live Journal v roce 2003, kdy mìla tato webová aplikace pøístup nìkolika miliónù dynamického zobrazení stránek bìhem jednoho dne. V takovémto prostøedí vysoké zátì¾e obstála a stává se dnes bì¾nou souèástí vrstev webových arhitektur v prostøedí vysoké zátì¾e.

Fyzickým úlo¾i¹tìm pro Memcached je operaèní pamì» RAM. Do pamìti ukládá hodnoty na principu Key-Value, èili ka¾dá hodnota je ukládána a ètena podle konkrétního klíèe. Pøipojení aplikaèní vrstvy k jednotlivým serverùm s Memcached není nikterak slo¾ité. Tìchto cache serverù, neboli uzlù, mù¾e být i více a je mo¾né urèit v jakém pomìru se budou hodnoty do jednotlivých uzlù ukládat. Ne v¹echny uzly toti¾ mohou mít stejné hardwarové vybavení, zejména stejnou velikost operaèní pamìti RAM. Aplikaèní vrstva nemusí znát informace o tom, na jakém konkrétním uzlu se ulo¾ila jaká hodnota. Pouze za¹le Memcached po¾adavek pro hodnotu podle klíèe a Memcached u¾ sama rozhoduje na kterém z uzlù se tato hodnota nachází. V¹echny hodnoty jsou ukládány serializované, nebo v textové formì, a nebo v nìjakém jiném standardizovaném formátu, který mù¾e urèit aplikaèní vrstva.\cite{memcached}

Systém Memcached pøedstavuje optimálního kandidáta pro tvorbu aplikaèní distribuované cache pro dynamické webové aplikace. Ov¹em vzhledem k nároènosti po¾adavkù pro tuto vrstvu webové architektury je dùle¾itý správný návrh a implementace aplikace. To z toho dùvodu, aby byla ukládána a zobrazována èerstvá, aktuální a správná data pro zobrazení korektních informací pro u¾ivatele webové aplikace.

\podsekce{Specifikace aplikace}
\label{sec:app-model-memcached}
Pro aplikaèní vrstvu byl pou¾it programovací jazy PHP s MVC frameworkem Symfony 2. Ka¾dý MVC framework by mìl pracovat s daty a jejich úlo¾i¹tìm ve vrstvì Model. Vyjímkou by nemìli být ani data ukládána pomocí distribuované aplikaèní cache Memcached.

Model aplikaèní vrstvy je rozdìlen na dal¹í ètyøi vrstvy, kde ka¾dá z nich má svùj jasnì definovaný úèel. První vrstvou je vrstva Service, neboli vrstva, která je pøístupna z ostatních vrstev MVC frameworku. Této vrstvì mohou být pøedány i nìjaké parametry. Servisní vrstva po¾adavek zpracuje, zpracuje pøedané parametry a pøedá øízení dal¹í vrstvì modelu, kterou je DAO, neboli Data Access Object. Úèelem této vrstvy je vybrat zpùsob pøistupu ke konkrétním typùm úlo¾i¹». Jednotlivé typy úlo¾i¹» jsou pøístupné pomocí vrstvy s názvem Mapper. Pro ka¾dý typ úlo¾i¹tì existuje Mapper, který má za úkol realizovat daný po¾adavek na konkrétní úlo¾i¹tì, napøíklad databázi èi aplikaèní distribuovanou cache. Úlo¾i¹tì tak tvoøí poslední vrstvu pro Model.

Data, neboli dotazy se kterými aplikace pracuje, mohou být tøí druhù z pohledu ètení z úlo¾i¹tì a ukládání do úlo¾i¹tì. Dotazy mohou být buï skalárem, èili jednou hodnotou, nebo entitou, neboli objektem s více atributy, èi kolekcí entit. Tyto typy dotazù jsou pøedány buï databázi a nebo distribuované aplikaèní cache, podle toho jak rozhodne vrstva DAO. Ka¾dý z tìchto dotazù definuje svùj SQL dotaz pro naètení z databáze a klíè pod kterým je ulo¾en do Memcached. Do Memcached jsou data ukládána serializovaná, a to z toho dùvodu, aby mohla být znovuzkonstruovatelná.

Nejvìt¹í problém obecnì pro cache vrstvy bývá jejich invalidace. V distribuovaných aplikaèních cache vrstvách mohou vznikat tzv. cache kaskády. Vyjímkou tomu nebylo ani v mém návrhu aplikace. Tyto kaskády vznikají tím, ¾e stejná data jsou interpretována v jiných kontextech. Jakmile dojde ke zmìnì tìchto dat, musí se zmìnit i celá tato kaskáda. Celá kaskáda se tak musí invalidovat. Jedná se o závislosti mezi jinými výsledky dotazù na stejných datech. Jako pøíklad mù¾u uvést, ¾e jeden stejný èlánek se mù¾e nacházet v kolekci nejnovìj¹ích èlánkù a zároveò v kolekci èlánkù dané kategorie. Jakmile dojde ke zmìnì èlánku v databázi, je potøeba invalidovat obì dvì tyto kolekce v cache pamìti Memcached. V této práci je tato skuteènost øe¹ena pomocí Interface Dependency Injection, která urèuje zpùsob pøedávání závislostí mezi jednotlivými objekty. Vytvoøí se tak nìjaká konkrétní kaskáda, která urèuje závislosti mezi konkrétními daty a jednotlivými dotazy mìnící data aplikace. Jakmile dojde ke zmìnì urèitých dat, tak kaskáda invaliduje v¹echny závislosti dotazù na tìchto datech.

Takto jsou splnìny v¹chny podmínky pro správnou práci a organizaci aplikaèní distribuované cache. Data jsou do cache pamìti ukládána v nejmen¹ích a jasnì definovaných formátech, podle jednoznaèného a konkrétního klíèe a jsou ukládána znovuzkonstruovatelná. Invalidace dat ulo¾enách v cache pamìti je øe¹ena systémem invalidaèních kaskád.

\podsekce{Dosa¾ené výsledky}
Po zhodnocení dosa¾ených výsledkù webové architektury s aplikaèní distribuovanou cache pomocí Memcached bylo potvrzeno dal¹í zrychlení odezvy odpovìdí na po¾adavky klientù v prostøedí vysoké zátì¾e. Opìt bylo nasimulováno prostøedí vysoké zátì¾e pomocí zátì¾ových testù programem Siege, kdy odpovìï po¾adovalo deset konkurenèních u¾ivatelù ve stejný moment ve tøech repeticích. Z XHProf profilování byly vyprofilovýny výsledky pro jeden po¾adavek jak pro situaci s pou¾itím aplikaèní distribuované cache, tak i pro situaci s optimalizovanou databází bez pou¾ití aplikaèní ditribuované cache. Výsledky tohoto profilování jsou takovéto:

\begin{itemize}
\item neoptimalované - bez Memcached - 25,9s
\item optimalizované - s Memcached - 0.95s
\end{itemize}

Výsledky potvrdili, ¾e do¹lo k velkému zrychlení odpovìdí. Zároveò bylo otestováno, ¾e aplikace stále zùstává dynamickou a v¹echna data jsou invalidována správnì a ve správný èas. Ov¹em stále zùstává obrovské zatí¾ení aplikaèní vrstvy. Z tohoto faktu vyplývá, ¾e pøi pou¾ití aplikaèní distribuované cache je potøeba poèítat se zatí¾ením aplikaèní vrstvy, které je nutno øe¹it pomocí více aplikaèních serverù a vyva¾ováním zátì¾e (load balancing) mezi tyto servery (viz. kapitola \ref{sec:load-balancing}). Server urèen pro aplikaèní distribuovanou cache nemìl ¾ádné velké vytí¾ení a tudí¾ se zde nachází potenciál, který se stále jestì mù¾e vyu¾ít.

\obrazek
\vlozeps{../images/graph-memcached.png}{0.4}
\endobr{Graf s výsledky porovnání doby trvání jednotlivých po¾adavkù pro repetice v prostøedí s Memcached a v prostøedí s optimalizovanou databází PostgreSQL}

\clearpage

\obrazek
\vlozeps{../images/xhprof-model-memcached-no-optim.png}{0.32}
\endobr{XHProf profilování aplikaèního modelu dotazù pøed optimalizací pomocí Memcached}

\obrazek
\vlozeps{../images/xhprof-model-memcached-optim.png}{0.32}
\endobr{XHProf profilování aplikaèního modelu dotazù po optimalizaci pomocí Memcached}

\clearpage

\obrazek
\vlozeps{../images/memcached-architecture.png}{0.5}
\endobr{Výsledné zapojení webové architektury s aplikaèní distribuovanou cache vrstvou Memcached}


% Reverse Proxy Cache
\sekce{Reverzní proxy cache}
\label{sec:reverse-proxy-cache}
Nejrychlej¹ím a nejefektivnìj¹í zpùsobem zùstává stále pou¾ití reverzní proxy cache. Ov¹em aplikace tak pøichází o dynamiènost a stává se více statickou. Ale i tak se dají najít situace, kdy je mo¾né pou¾ití statického ukládání do cache pamìti reverzní proxy cache. Napøíklad archiv èlánkù urèitého období mù¾e být statického charakteru, ponìvad¾ takovýto obsah se dynamicky èasto nemìní. Existuje spousta programù pro øe¹ení klasické reverzní proxy cache (viz. kapitola \ref{sec:reverse-proxy}). V této èásti své práce popí¹u netradièní zpùsob pro øe¹ení reverzní proxy cache, ale tento zpùsob má své uplatnìní v praxi a navazuje na pøedchozí kapitolu \ref{sec:memcached}.

\podsekce{Optimalizace pomocí reverzní proxy cache Nginx s Memcached}
Jedním z moderních nástrojù pro reverzní proxy cache a se nazývá Nginx. Nginx má spoustu dal¹ích funkcionalit a modulù. Obsahuje modul pro webový server, pro rozlo¾ení zátì¾e (load balancing), pro geografické rozlo¾ení zátì¾e, pro servírování obrázkù, pro podporu memcached, a spoustu dal¹ích modulù. Tento opravdu silný nástroj byl vytvoøen programátorem Igorem Sysoevem v roce 2004 pro druhou nejvìt¹í ruskou webovou aplikaci Rambler.ru, která servírovala pøes 500 milionù HTTP odpovìdí bìhem jednoho dne. Nginx jako reverzní proxy cache je øízen HTTP hlavièkami jako klasická reverzní proxy cache (viz. kapitola \ref{sec:http-headers}). HTTP odpovìdi ukládá do pøesnì definovaného adresáøe souborového systému. Tento klasický zpùsob se hodí pro skuteèný statický obsah, kterým jsou obrázky, CSS soubory, JS soubory apod.\cite{nginx}

V této práci bylo pou¾ito Nginx jako reverzní proxy cache s modulem pro Memcached. Tento netradièní zpùsob øe¹ení reverzní proxy cache s sebou pøiná¹í urèité výhody. Jednou z výhod je, ¾e øízení Memcached je plnì pod kontrolou aplikaèní vrstvy. Aplikaèní vrstva ukládá a invaliduje výsledné HTTP odpovìdi na HTTP po¾adavky klientù do Memcached pod URL adresou po¾adavku. Memcached je pou¾ita reverzní proxy cache Nginx pro ètení. Jakmile Nginx obdr¾í HTTP po¾adavek a z konfigurace zjistí, ¾e HTTP odpovìï je mo¾né hledat pod URL adresou v pamìti Memcached, zkusí ji tam najít. Pokud ji Nginx nenalezne, propustí tento po¾adavek dále na aplikaèní vrstvu. Aplikaèní vrstva sestaví HTTP odpovìï, ulo¾í ji pod URL adresou HTTP po¾adavku do cache pamìti Memcached, a po¹le klientovi. Pøi pøí¹tím HTTP po¾adavku Nginx nalezne HTTP odpvìï v pamìti Memcached a po¹le klientovi, ani¾ by po¾adavek propustil na aplikaèní vrstvu. Takovéto chování je obdobné jako pøi klasickém nastavení reverzní proxy cache, ov¹em s tím rozdílem, ¾e ukládání a invalidace nejsou øízeny HTTP hlavièkami. Dal¹i výhodou mù¾e být vyu¾ití Ajaxu a metodiky aplikaèní distribuované cache pro vytvoøení dynamického pøístupu ukládání a invalidace dat do cache pamìti pro Memcached a Nginx.\cite{nginx-memcached}

\obrazek
\vlozeps{../images/nginx-memcached.png}{0.5}
\endobr{Schéma webové architektury pøi pou¾ití Nginx s modulem pro Memcached}

\podsekce{Vyu¾ití Ajax a webových slu¾eb pro NGINX s Memcached}
\label{sec:ajax-nginx-memcached}
Aplikaèní vrstva nemusí ukládat do cache pamìti Memcached pro Nginx pouze celé kompletní HTML stránky, neboli odpovìdi pro HTTP po¾adavky. Mù¾e ukládat i dal¹í typy odpovìdí, jako napøíklad Ajaxem standardizovaný JSON, co¾ je druh pøenosu dat mezi Aplikaèní vrstvou a technologií Ajax klientské vrstvy. Díky Ajax tak mù¾e dojít k rozdìlení jednoho HTTP po¾adavku na více rùzných po¾adavkù. Klient za¹le HTTP po¾adavek a Nginx navrátí HTTP odpovìï ve formì statické HTML stránky, která obsahuje nìkolik dal¹ích po¾adavkù pomocí Ajax. Odpovìdi na tyto Ajax po¾adavky mohou být dynamického èi statického charakteru. Tímto zpùsobem je webová aplikace rozdìlena mezi více webových slu¾eb, které mohou pracovat samostatnìji a nezávisle na sobì, a aplikace se tak stává více ¹kálovatelnou.

Vzhledem k tomu, ¾e aplikace a její logika øídí ukládání do cache pamìti Memcached, mù¾e tak øídit i jejich invalidaci podobným zpùsobem jako v aplikaèní distribuované cache (viz. kapitola \ref{sec:app-model-memcached}). Hlavní rozdíl je v tom, ¾e v pøípadì aplikaèní distribuované cache je práce s cache øízena plnì aplikaèní vrstvou, jak pøi zmìnì tak ètení. V tomto pøípadì dochází k velkému vytí¾ení aplikaèní vrstvy (viz. kapitola \ref{sec:memcached}). Kde¾to systém webové architektury s Nginx a Memcached je øízen aplikaèní vrstvou pro zmìnu a invalidaci dat, a reverzní proxy cache vrstvou pro ètení a získání dat z cache pamìti. Dochází tak k hybridnímu zpùsobu práce s reverzní proxy cache a aplikaèní distribuovanou cache. Toho je mo¾né vyu¾ít pro webové slu¾by, které tak mohou být i dynamického charakteru.

\podsekce{Dosa¾ené výsledky}
Z dosa¾ených výsledkù vyplývá absolutnì nejrychlej¹í doba pro HTTP odpovìdi ze v¹ech uvedených experimentù. Opìt bylo nasimulováno prostøedí vysoké zátì¾e pro deset konkurenèních u¾ivatelù v jeden samý okam¾ik a ve tøech repeticích. Ov¹em tento experiment má tu nevýhodu, ¾e obsah aplikace se stává statickým. Ov¹em pøi aplikaci my¹lenky z kapitoly \ref{sec:ajax-nginx-memcached} jsou HTTP odpovìdi servírovány u¾ivateli velice rychle, a jakmile jsou data zmìnìna, mù¾e dojít k ivalidaci dat pomocí aplikaèní vrstvy (viz. kapitola \ref{sec:ajax-nginx-memcached}). Tak se obsah webové aplikace mù¾e stát dynamickým. Tento zpùsob dynamického chování byl implementován v aplikaèní vrstvì pro Nginx.

\obrazek
\vlozeps{../images/graph-nginx.png}{0.4}
\endobr{Graf s výsledky porovnání doby trvání jednotlivých po¾adavkù pro repetice s reverzní proxy cache Nginx s pamìtí Memcached}

\clearpage

\obrazek
\vlozeps{../images/nginx-architecture.png}{0.5}
\endobr{Výsledné zapojení webové architektury s reverzní proxy cache vrstvou Nginx s pamìtí Memcached}



% Diskuze
\kapitola{Diskuze}
Tato práce se nejvíce zamìøila na jednotlivé vrstvy webové architektury, obzvlá¹tì na vrstvy serverové èásti. Celkem byly provedeny ètyøi vìt¹í experimenty, jeden experiment pro aplikaèní vrstvu, jeden pro databázovou vrstvu, jeden pro aplikaèní distribuovanou cache vrstvu a jeden pro reverzní proxy cache vrstvu. Pro ka¾dý z testù byla navr¾ena, implementována, otestována a vyhodnocena jejich webová architektura, konfigurace, funkcionalita, zátì¾ové testy a schopnost obstát v prostøedí vysoké zátì¾e.

První experiment se týkal aplikaèní vrstvy a mo¾nosti vyu¾ití Opcode Cache pro programovací jazyk PHP (viz. kapitola \ref{sec:optim-apc}). Konfigurace, implementace a realizace tohoto experimentu nebyla a¾ tak nároèná a pracná. Vzhledem k nastudovaným teoretickým základùm, kdy bylo známo jakou cestou se vydat, nebyl experiment a¾ tak slo¾itý a výsledky jsou více ne¾ dobré. Tento postup je tedy mo¾né doporuèit pro ostré nasazení. V prostøedí s opravdu vysokou zátì¾í je nasazení více aplikaèních serverù pro rozlo¾ení zátì¾e (load balancing) nevyhnutelné.

Druhý experiment pracoval se standartní tøívrstvou architekturou, tj. klientem, aplikaèním serverem a databázovým systémem (viz. kapitola \ref{sec:optim-database}). Tento experiment byl zamìøen na databázový systém, jeho pøístupnost a èasovou odezvu na SQL dotazy v prostøedí vysoké zátì¾e. V tomto smìru bylo zji¹tìno, ¾e optimalizace databáze je velice dùle¾itá, proto¾e se pøístup a odpovìdi na SQL dotazy mohou zrychlit v øádech sekund, minut i hodin. Samozøejmì jakmile se prostøedí vysoké zátì¾e zaène zvìt¹ovat a zaène je¹tì více rùst zatí¾ení databáze, je potøeba sáhnout k dal¹ím krokùm jako napøíklad partitioning nebo replikace. Samozøejmì v architektuøe webových systémù bývá databázová vrstva tou nejvytí¾enìj¹í a nejpomalej¹í vrstvou. Proto je dobré zamìøit pozornost i na to, jak zmen¹it poèet SQL dotazù do databáze.

Ve tøetím experimentu do¹lo k roz¹íøení tøívrstvé architektury o vrstvu aplikaèní distribuované cache (viz. kapitola \ref{sec:memcached}). Právì diký této vrstvì je mo¾né získat rychlej¹í pøístup k ji¾ jednou naèteným datùm z databáze. Zároveò zùstává obsah webové aplikace dynamický. Ov¹em je nutné zmínit, ¾e zde zùstává velké zatí¾ení aplikaèní vrstvy. Proto mù¾e v prostøedí vysoké zátì¾e nastat situace, kdy je potøeba mít více aplikaèních serverù pro rozlo¾ení zátì¾e. Výsledky testù simulovaného prostøedí vysoké zátì¾e byly rozhodnì lep¹í s vyu¾itím aplikaèní distribuované cache Memcached ne¾ výsledky pouze s databází. Ov¹em je potøeba pøihlédnout k nutnosti zajistit funkcionalitu aplikaèní distribuované cache v jádru aplikace a v její logice. Je potøeba zajistit aplikaci pøístup ke cache pamìti, zajistit ukládání dat ve spravném, dohodnutém a znovuzkonstruovatelném formátu, a hlavnì zajistit jejich správnou a vèasnou invalidaci. S po¾adavkem aplikaèní distribuované cache je potøeba poèítat ji¾ pøi návrhu aplikace, proto¾e jinak mù¾e docházet k èastým chybám a náklady, a» u¾ èasové èi finanèní, na zavedení této vrstvy mohou být vysoké.

V posledním experimentu probìhlo zkombinování reverzní proxy cache Nginx s aplikaèní distribuovanou cache Memcached (viz. kapitola \ref{sec:reverse-proxy-cache}). První HTTP po¾adavky zpracovala aplikaèní vrstva, vytvoøila HTTP odpovìï a ulo¾ila ji do cache pamìti Memcached pro reverzní proxy cache Nginx. Pøi pøí¹tím dotazu na¹la reverzní proxy cache odpovìï v cache pamìti a okam¾itì ji vrátila klientovi. Invalidace tìchto odpovìdí probíhá automaticky pomocí Memcached a èasového razítka. Tento zpùsob práce s obsahem webové aplikace se tak stává statickým. Ov¹em vzhledem k tomu, ¾e odpovìdi ukládá aplikaèní vrstva, mù¾e tyto odpovìdi také invalidovat podobnì jako v pøípadì aplikaèní distribuované cache. Jeden HTTP po¾adavek se tak dá rozlo¾it na více po¾adavkù pomocí technologie Ajax. Odpovìdi na jednotlivé po¾adavky Ajax jsou také ukládány do cache pamìti Memcached a jejich invalidace mù¾e probìhnout ihned pøi zmìnì. Dochází tak k hybridnímu vyu¾ití reverzní proxy cache a aplikaèní distribuované cache. Výsledky pro tento zpùsob práce byly více ne¾ uspokojivé. Obsah webové aplikace je dynamický a rychlý, a to díky re¾ii ukládání a invalidace na stranì aplikaèní distriboavané cache a re¾ii ètení na stranì reverzní proxy cache.

% Zaver
\kapitola{Závìr}
Závìrem je nutno øíci, ¾e webová architektura je natolik komplexní a nároèný systém, ¾e v nìm neexistuje jedno èi pár pravidel, která je nutno dodr¾et a díky kterým bude webová aplikace pøipravená, optimalizovaná a provozuschopná v prostøedí vysoké zátì¾e. Existuje spousta osvìdèených nástrojù a postupù øe¹ení, které umí pomoci architektuøe k odlehèení vytí¾enosti, ov¹em je nutno je brát pouze jako rady a návody, ne jako závazná pravidla. Ka¾dá webová aplikace je toti¾ svým zpùsobem jedineèná, a vy¾aduje tak unikátní pøístup øe¹ení optimalizace. 

V první fázi je nejdùle¾itìj¹í identifikovat zdroj vytí¾ení. Jedná-li se o nìjaký z DoS útokù, nebo o nárazovou vytí¾enost, èi o dlouhodobé kontinuální vytí¾ení. Je mo¾né se zamìøit i na geografický pùvod tohoto vytí¾ení. Mù¾e se vyskytnout i chyba v konfiguraci èi implementaci nìkteré z vrstev architektury. K identifikování takových problémù jsou dùle¾ité profilery. V¾dy je dobré vìdìt, kdo, kdy, kde a jak stojí za vytí¾ením aplikace.

Dále je nutné rozli¹ovat, jaký typ dat aplikace poskytuje a která data jsou v prostøedí vysoké zátì¾e. Podle toho jestli se jedná o data statická èi dynamická, je mo¾né urèit, jakou dal¹í cestou optimalizace se vydat. Dùle¾itá je otázka zpracování dat. S webovou architekturou v prostøedí vysoké zátì¾e souvisí i vysoká míra dat nutných ke zpracovávání databází, ke které je nutno pøistupovat se zvlá¹tní obezøetností, ponìvad¾ mù¾e být tou nejvytí¾enìj¹í vrstvou architektury.

Pokud je mo¾né pøedvídat vysoké vytí¾ení aplikace, je dobré webovou architekturu na takové vytí¾ení pøipravit. Kdy¾ se webová aplikace od zaèátku vyvyjí tak, aby byla lehce ¹kálovatelná, její optimalaze a odlehèení zátì¾e bude o dost jednodu¹¹í. ©kálovatelnost je jedním z nejdùle¾itìj¹ích faktorù pro optimální chod aplikací ve vysokém vytí¾ení. Je toti¾ dobré umìt do webové architektury pøidat jiné vrstvy, funkcionality a uzly tak, aby odlehèily co nejvíce jiným vrstvám. Je dùle¾ité kombinovat rùzná øe¹ení a pøístupy.

Nezbytné je zvá¾it jaké jsou dostupné mo¾nosti øe¹ení. A» u¾ se jedná o mo¾nosti èasové, finanèní èi jiné. Nìkterá øe¹ení jsou nároèná èasovì, jiná zase finanènì. Mù¾e nastat i situace, kdy je stávající webová architektura ¹patnì navr¾ena, a tak ji lze jen tì¾ko, èi vùbec, roz¹íøit. Ov¹em ten, kdo rozhoduje o zpùsobu provedení optimalizace a odlehèení vytí¾enosti nejsou programátoøi, administrátoøi èi softwarový in¾enýøi, ale projektové vedení. To rozhoduje, jakou cestou se webová aplikace bude ubírat, jaký je její cíl, jak se má chovat k u¾ivatelùm a jaký je její smysl. Otázkou zùstává, jsou-li k rozhodnutím v¾dy dostateènì kompetentní z pohledu svých technických znalostí. V mnoha pøípadech se ale jedná o zhodnocení faktorù finanèních, èasových a technických. Ne ka¾dý pøístup k øe¹ení vysoké zátì¾e je efektivní a ne ka¾dý pøístup je levný. Vìt¹inou se jedná o kompromis mezi dostupnými finanèními a èasovými mo¾nostmi.


\begin{literatura}

\citace{sledovani-zatizeni}{Rankin, 2010}{\autor{Kyle Rankin}
%\citace{sledovani-zatizeni}{1}{\autor{Kyle Rankin}
\nazev{Hack and / - Linux Troubleshooting, Part I: High Load} [online]. Linux Journal, 1.kvìtna 2010. URL: http://www.linuxjournal.com/magazine/hack-and-linux-troubleshooting-part-i-high-load}

\citace{dos}{Khan, 2009}{\autor{Faisal Khan}
%\citace{dos}{2}{\autor{Faisal Khan}
\nazev{Dos Attacks Overview - What are DoS attacks} [online]. Dos Attacks, 5.záøí 2009. URL: http://dos-attacks.com/what-are-dos-attacks/}

\citace{anonymous}{Èepský, 2012}{\autor{Pavel Èepský}
%\citace{anonymous}{3}{\autor{Pavel Èepský}
\nazev{Útoky jménem Anonymous: Jak se rodí hackeøi?} [online]. Lupa.cz, 7.února 2012. URL: http://www.lupa.cz/clanky/utoky-jmenem-anonymous-jak-se-rodi-hackeri/}

\citace{tri-vrstvy}{Zendulka, 2005}{\autor{Doc.Ing.Jaroslav Zendulka,CSc.}
%\citace{tri-vrstvy}{4}{\autor{Doc.Ing.Jaroslav Zendulka,CSc.}
\nazev{10. Architektura klient/server a tøívrstvá architektura} [online]. Brno: VUT-FIT, 2005. URL: http://www.fit.vutbr.cz/study/courses/DSI/public/pdf/nove/10\_clsrv.pdf}

\citace{ajax}{McLaughlin, 2005}{\autor{Brett McLaughlin}
%\citace{ajax}{5}{\autor{Brett McLaughlin}
\nazev{Mastering Ajax} [online]. Ibm develper works, 6.prosince 2005. URL: http://www.ibm.com/developerworks/web/library/wa-ajaxintro1/index.html}

\citace{design-patterns}{Pecinovský, 2007}{\autor{Rudolf Pecinovský}
%\citace{design-patterns}{6}{\autor{Rudolf Pecinovský}
\nazev{Návrhové vzory : 33 vzorových postupù pro objektové programování} 1. vyd. Brno: Computer Press, 2007. 527 s. ISBN 978-80-251-1582-4}

\citace{optimalizace-sql}{Blaha, 2007}{\autor{Bohdan Blaha}
%\citace{optimalizace-sql}{7}{\autor{Bohdan Blaha}
\nazev{SQL Optimalizace v Oracle} Praha: Unicorn College, 2010. 47 s. URL:
http://www.unicorncollege.cz/katalog-bakalarskych-praci/bohdan-blaha/attachments/Blaha\_Bohdan\_-\_Optimalizace\_SQL\_dotaz\%C5\%AF\_v\_datab\%C3\%A1zi\_Oracle.pdf}

\citace{partitioning-db}{White, 2009}{\autor{Eli White}
%\citace{partitioning-db}{8}{\autor{Eli White}
\nazev{Habits of Highly Scalable Web Applications} DCPHP Konference. 2009}

\citace{replikace}{Vondra, 2011}{\autor{Tomá¹ Vondra}
%\citace{replikace}{9}{\autor{Tomá¹ Vondra}
\nazev{Replikace v PostgreSQL} CSPUG Konference. Praha, 2011}

%\citace{rfc-http}{RFC:2616, 1999}{\autor{R. Fielding, UC Irvine, J. Gettys, J. Mogul, Compaq, H. Frystyk, L. Masinter, Xerox, P. Leach, Microsoft, T. Berners-Lee, W3C/MIT}
\citace{rfc-http}{RFC:2616, 1999}{\autor{R. Fielding, UC Irvine, J. Gettys, J. Mogul, Compaq, H. Frystyk, L. Masinter, Xerox, P. Leach, Microsoft, T. Berners-Lee, W3C/MIT}
\nazev{RFC:2616 - Hypertext Transfer Protocol -- HTTP/1.1}}

\citace{proxy-cache}{Nottingham, 2012}{\autor{Mark Nottingham}
%\citace{proxy-cache}{11}{\autor{Mark Nottingham}
\nazev{CACHING TUTORIAL for Web Authors and Webmasters} [online]. Mark Nottingham, 1998-2012. URL: http://www.mnot.net/cache\_docs/}

\citace{xhprof}{Onderka, 2011}{\autor{Jakub Onderka}
%\citace{xhprof}{12}{\autor{Jakub Onderka}
\nazev{Profilování PHP skriptù pomocí XHProf} [online]. Zdrojak.cz, 24.ledna 2011. URL: http://www.zdrojak.cz/clanky/profilovani-php-skriptu-pomoci-xhprof/}

%\citace{apc}{13}{\autor{Vito Chin}
\citace{apc}{Chin, 2010}{\autor{Vito Chin}
\nazev{Understanding APC} [online]. Techportal Ibuildings, 7.øíjna 2010. URL: http://techportal.ibuildings.com/2010/10/07/understanding-apc/}

%\citace{memcached}{14}{\autor{Brad Fitzpatrick}
\citace{memcached}{Fitzpatrick, 2004}{\autor{Brad Fitzpatrick}
\nazev{Distributed Caching with Memcached} [online]. Linux Journal, 1.srpna 2004. URL: http://www.linuxjournal.com/article/7451}

%\citace{nginx}{15}{\autor{Will Reese}
\citace{nginx}{Reese, 2008}{\autor{Will Reese}
\nazev{Nginx: the High-Performance Web Server and Reverse Proxy} [online]. Linux Journal, 1.záøí 2008. URL: http://www.linuxjournal.com/magazine/nginx-high-performance-web-server-and-reverse-proxy}

%\citace{nginx-memcached}{16}{\autor{Ilya Grigorik}
\citace{nginx-memcached}{Grigorik, 2008}{\autor{Ilya Grigorik}
\nazev{Nginx and Memcached, a 400\% boost!} [online]. Ingvita, 11.února 2008. URL: http://www.igvita.com/2008/02/11/nginx-and-memcached-a-400-boost/}

%\citace{cdn}{17}{\autor{Bc. Pavel Mikulka}
\citace{cdn}{Mikulka, 2008}{\autor{Bc. Pavel Mikulka}
\nazev{Implementace CDN a clusteringu v prostøedí GNU/LINUX s testy výkonnosti}, Brno: VUT, 2008. 65 s. URL: http://www.vutbr.cz/www\_base/zav\_prace\_soubor\_verejne.php?file\_id=7793} 

%\citace{virtual}{18}{\autor{Petr Hrù¹a}
\citace{virtual}{Hrù¹a, 2011}{\autor{Petr Hrù¹a}
\nazev{Výhody a nevýhody virtualizace platforem a aktuální nabídka} [online]. Aquasoft, 24.listopadu 2011. URL: http://www.aquasoft.eu/blog/nazor_odbornika.php?nazor=450} 


\end{literatura}

% Prilohy
\prilohy

\priloha{APC webové rozhraní}
\vlozeps{../images/apc-web.png}{0.5}

\priloha{XHProf graf závislostí funkcí a metod Symfony2}
\vlozeps{../images/callgraph-xhprof.png}{0.275}

\priloha{AJAX dynamické po¾adavky pro reverzní proxy cache Nginx}
\vlozeps{../images/ajax-nginx.png}{0.4}

\priloha{DVD s aplikací pro aplikaèní distribuovanou cache Memcached}

\end{document}
