% preambule dokumentu
\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{dipp2}
\begin{document}
\pagestyle{headings}


% uvodni cast zaverecne prace
\titul{Webová architektura v prostředí vysoké zátěže}{Bc. Jakub Škrha}{Ing. Michael Štencl, Ph.D.}{Brno 2012}
\podekovani{Text poděkování}
\prohlaseni{Text prohlášení}{místo a datum prohlášení}
\abstract{Citace práce v anglickém jazyce}{abstrakt práce v anglickém jazyce}

\abstrakt{Citace práce v českém jazyce}{abstrakt práce v českém jazyce}
\obsah
\cislovat{3}



% Uvod
\kapitola{Úvod}
Něco na téma jak vzniká vysoká zátěž na iternetu, jaký je vliv internetu, roustoucí zájem o internet a stoupající zátěž. Uvidíme, napíšu to jako poslední.


% Nezadouci vlivy
\kapitola{Nežádoucí vlivy a důsledky vysoké zátěže}
Úspěch internetových a webových projektů je přímo úměrný výši návštěvnosti, používání a registracím a samozřejmě výdělku z aplikace. Obecně se dá předpokládat, že čím je větší návštěvnost projektu, tím jsou větší i zisky. A to už díky reklamní činnosti či placenných služeb. Ovšem zde se dá velice jasně konstatovat, že tyto výdělky nejsou až tak lehce získané. Nejenom, že si musí aplikace získat své uživatele, ale musí řešit problémy s obrovským počtem uživatelů, čili problémy s vysokou zátěží.

Vysoká zátěž může mít ve své podstatě několik nežádoucích vlivů, které můžou mít až katastrofický scénář. Může docházet k takovému zatížení aplikace, že odpovědi na jednotlivé požadavky mohou trvat velice dlouhou dobu. Tím pádem si uživatel může rozmýšlet, zda-li příště navštíví tuto webovou aplikaci, či zkusí některou z jiných možných konkurenčních alternativ. Takto velice nepříznivý scénář může být ještě horším. A to tak, že díky velkému zatížení dojde dokonce k výpadku celé aplikace, a tím pádem už se uživateli nedostane vůbec žádné odpovědi na jeho požadavek. Při takovém scénáři existuje vysoká pravděpodobnost ztráty a poklesu uživatelů, což může znamenat velký pokles zisků pro firmu či společnost.

Po technické stránce se při velké zátěži vytvoří pro každý požadavek celý samostatný proces či vlákno procesu, které si klade nároky na procesor CPU a operační paměť RAM serveru. Vznikají tak i procesy, které musí čekat na přidělení takových prostředků a tím pádem zatížení, které roste a čeká na vykonání může server přetížit až už nebude provozuschopný. Takovéto zatížení je možné pozorovat při výpisu právě běžících procesů a jejich vytížení na RAM či CPU (například příkazem top). Dále je možno pozorovat tzv. "Load Average" (například příkazem uptime), které představuje počet procesů čekajích na přidělení prostředků během jedné, pěti či patnácti minut.\cite{sledovani-zatizeni} Takto je možné sledovat jaké jsou nežádoucí vlivy vysoké zátěže na technické úrovni.

Je nutné podotknout, že existuje i jeden skrytý a ne tak viditelný důsledek vysoké zátěže. Tím je fakt, že jakmile se začne zvedat návštěvnost uživatelů, a tím pádem i zátěž aplikace, projektové vedení si klade požadavek, aby tento nárůst uživatelů již zůstal, a naopak se dokonce i zvětšoval. A to vše z toho důvodu, že velký počet uživatelů, znamená velkou zátěž pro aplikaci, ovšem velký finanční přínos pro firmu.



% Zneuziti
\kapitola{Zneužití vysoké zátěže}
Z nežádoucích vlivů a důsledků uvedených v předchozí kapitole vyplývá, že rostocí zátěž může způsobit katastrofické scénáře, čili může negativně působit na celou aplikaci. Tento poznatek představuje obrovské riziko při jeho zneužití. Zpravidla může být způsobeno úmyslným či neúmyslným chováním nějaké organizace či jedince. Takovéto zneužití má svoji oporu i v zákonech, kde hrozí až odmětí svobody několika let.

U webových projektů je možné z těch neúmyslných zmínit například nějaké klientské chyby programů, či větší míru indexace robotů jednotlivých vyhledáváčů. Roboti vyhledávačů pravidelně prochází webovou aplikaci a indexují její jednotlivé části, a tyto výsledky zohledňují následně ve svých výsledcích ve vyhledávání. Tito roboti mohou představovat nežádoucí zátěž.

Tím druhým a daleko nebezpečnějším úmyslným způsobem lze mnohdy způsobit daleko větší škody. Toto úmyslné chování už je klasifikováno jako útok na webovou aplikaci za který hrozí postih podle zákona. Tyto útoky jsou nazývány DoS, neboli "Denial of Service". Jejich cílem je ochromit infrastrukturu celé webové architektury přehlcením požadavků na které aplikace bude vytvářet odpovědi. Tyty útoky využívají chyb, nedostatků či nedokonalostí protokolů ICMP, TCP, UDP a jiných protokolů či samotných webových aplikací. Například útok s názvem "Tcp Syn Flood", kdy útočník vytíží aplikaci SYN pakety pro navázání spojení využívá nedokonalosti TCP protokolu. Dalšími útoky využívajích nedokonalostí mohou být "ICMP Flood", "Ping of Death", "Smurf Attack", "IP Spoofing", "Fraggle Attack", "Teardrop", "Application level" aj. Ovšem proti většině těchto útoků už dnes existuje ochrana ve formě servisních instalací jednotlivých systémů či aktualizací programů síťových zařízení a nebo lehkou konfigurací. \cite{dos}

Ovšem co v dnešní době představuje daleko větší nebezpečí, jsou útoky typu DDoS, neboli "Distributed Denial of Service". V tomto případě jako princip obdobný jako u DoS, ovšem s tím, že je úkol distribuovaný. Tedy je spuštěn z několika stanic, několika uživateli a pomocí různých nástrojů. Tento způsob je tedy daleko více organizovaný a daleko více nebezpečný a učinnější. \cite{dos}

Právě v dnešních dnech se stává symbolem boje za svobodu internetu skupina s názvem Anonymous, která využívá útoků DDoS. Při svých útocích využívají například útoky typu "Slowloris", kdy útočník využívá protokolu HTTP na aplikační úrovni a chce celou odpověď na svůj požadavek. Při navázaném spojení ovšem odesílá HTTP hlavičky co nejpomaleji, aby tak co nejvíce prodloužili dobu spojení a získal prostor pro vytvoření dalšího spojení, čili další zátěže. Tato skupina napadá webové aplikace veřejnosti neoblíbených politických stran, vládních organizací, protipirátských asociací a jiných subjektů. Získávají si tím obrovskou podporu ve společnosti i médiích, která s jejich kroky souhlasí. Dokonce pro své útoky využívají i příznivců z řad veřejnosti, kteří nemusí odborníky informačních technologií. Stačí jim si pouze stáhnout upravený program, v určený čas ho spustit a připojit. Útoky probíhají hlášeně či neohlášeně, organizovaně a ditribuovaně. Otázkou zůstává, kdy jejich konání přeroste z útoků pro dobro společnosti, a stanou se útoky pro vydírání, posílení moci, či za účelem finančního obohacení. V ten moment i společnost, která je v tyto dny podporuje, může pocítit, jak jsou pro ně nebezpeční. I v historii Země nalezneme spoustu skupin, které byly lidmi podporovány a nakonec se z nich stal symbol krutosti, tyranie, úzkosti a neštěstí. Proto je důležité jejich útoky nepodceňovat a umět se bránit. Má práce se nezabývá konkrétním řešením nějakého z typů útoků, ale zabývá se obecně vysokou zátěží, a jak ustát narůst obrovské zátěže a tedy i nějaký útok.\cite{anonymous}



% Tri a vice vrstev
\kapitola{Tří a vícevrstvá architektura webových systémů}
Webová architektura je ve svém základu třívrstvá. První vrstvu tvoří klient, neboli uživatel se svým Hardware a Software, a svými aplikačními požadavky. Druhou vrstvu tvoří aplikační server, který zpracovává požadavky aplikace, tedy požadavky klienta, zpracuje tento požadavek, vytvoří odpověď a zašle zpět klientovi. Ovšem k tomu, aby mohl tuto odpověď vytvořit, potřebuje i data aplikace, která jsou uloženy v perzistentní databázi, která tvoří třetí a poslední vrstvu třívrstvé architektury. Každá z vrstev, tedy prezentační, aplikační i datová má své místo a svou správu v aplikaci.\cite{tri-vrstvy}

\obrazek
\vlozeps{../images/3layer.png}{0.6}
\endobr{Tří vrstvá architektura webových aplikací}

V architektuře webových aplikací s vysokou zátěží už je potřeba jiného přístupu. V tomto případě se dá říci, že je třívrstvá architektura nedostačující. Je potřeba počítat se síťovími prvky pro load balancing, s více aplikačními stroji, s databázovými replikacemi, s DNS řešením pro geografické rozdělení zátěže, s CDN pro rozdělení zátěže přidělování obsahu, s vrstvami pro cache aplikace a s dalšími vrstvami pro backendové či frontendové aplikace a služby. V tomto případě neexstuje žádné jasně dané a pevné řešení, každá aplikace si s sebou nese své individuální a charakteristické řešení a strategii, i když některé osvědčené postupy se opakují. Tyto strategie už nesou název vícevrstvá architektura.

\obrazek
\vlozeps{../images/wikimedia.png}{0.3}
\endobr{Webová architektura společnosti Wikimedia provozující Wikipedia.org}

Nutkno podoknout, že webové architektury využívají nejčastěji ke své komunikaci mezi klientem a architekturou protokol HTTP, který využívá portu číslo 80 a protokolu TCP pro komunikaci. Proto je celá má odborná studie založena na práci s tímto protokolem.


% Aplikacni vrstva
\kapitola{Aplikační vrstva}
Aplikační vrstva představuje jádro webové architektury. Jejím účelem je příjmout a zpracovat klientův požadavek, vytvořit odpověď a tuto odpověď zaslat nazpět klientovi. Na aplikační vrstvu jsou tak kladeny úkoly celé režie procesu tvorby odpovědi, a tím pádem má velkou zoodpovědnost a mnohdy i největší zátěž.

\sekce{Webová aplikační architektura MVC}
V dnešní moderní aplikační vrstvě se používá aplikační architektura návrhového vzoru MVC pro přehlednější a rychlejsí způsob tvorby aplikace. Tato zkratka vychází z tří slov Model, View a Controller, které představují tři základní vrstvy aplikační architektury. Často bývá označovám i jako MVC framework, který rozděluje aplikaci do tří modulů. \cite{design-patterns}

Controller je prvotní inicializační vrstva každého požadavku. Zpracovává příchozí data, parametry a atributy dané akce od uživatele, provádí jejich kontrolu a formátování. Stará se i o zabezpečení dané konkrétní akce vrstvy Controller. Často spolupracuje s vrstvou Model, které předává požadavky na data aplikace, a tyto data dále zpracovává pro předání do vrstvy View. \cite{design-patterns}

Model má za úkol přistupovat k datovým úložištím, a to ať už k perzistentní databázi nebo souborovému systému, cache či jiným typům úložišť. Zapouzdřuje tak datovou logiku frameworku. Často se jedná o soubor dalších návrhových vzorů, kde se může vyskytnout přepravka (Crate) či jejich kolekce pro přenášení dat, zástupce (Proxy) pro přístup k implemtacím nad přepravkami, příkaz (Command) pro vykonání nějaké akce či příkazu, strategie (Strategy) pro určení nějaké konkrétního algoritmu ze skupiny algoritmů nad určitou úlohou, a mnohé další z návrhových vzorů. Modelová vrstva bývá označována za nejsložitější vrstvu, a právě proto je potřeba dodržovat techniky OOP včetně návrhových vzorů pro další možnou rozšiřitelnost a pro přehlednost. \cite{design-patterns}
%Existují i různé knihovní implementace modelové vrstvy, jako například ORM, neboli Object Relationship Mapping. 

View klade důraz na presentační úroveň, tedy na grafickou a jinou interakci s uživatelem. Zpracovává tak výsledek práce vrstvy Controller nad vrstvou Model a zobrazuje výsledek určitých operací. Často využívá nějakých šablonovacích přístupů. \cite{design-patterns}

\obrazek
\vlozeps{../images/mvc.png}{0.35}
\endobr{Návrhový vzor MVC a jeho životní cyklus}

\sekce{Optimalizace aplikační vrstvy}
\label{sec:profiler}

Optimalizace na úrovni aplikační vrstvy může mít několik způsobů a přístupů. Tato činnost se týká převážně programátorů a softwarových inženýrů, kteří mají za úkol vývoj a údržbu aplikační vrstvy. K tomu, aby se dali identifikovat problematické části pro optimalizaci slouží tzv. profilery. Ty mají obecně za úkol vyprofilovat jednotlivé funkce, metody, procedury, dotazy a příkazy, které se na dané vrstvě, již je profiler určen, vyskytují, a určit jejich dobu trvání, počet volání, čas spuštění, závislosti a další parametry. Profilování, neboli určení kandidátů pro optimalizaci, je prvním a nejdůležitějším krokem pro optimalizaci aplikační vrstvy webové architektury. Další kroky se týkají především těchto oblastí:

\begin{itemize}
\item Výběr nejoptimálnějšího algoritmu pro danou úlohu
\item Výběr nejrychlejšího MVC frameworku
\item Vytváření cache souborů aplikace
\item Způsob překladu a vykonání zdrojových souborů
\item Přidání další vrstvy architektury - aplikační cache
\end{itemize}

\sekce{Druhy aplikačních vrstev}
Existuje celá škála různých programovacích jazyků a webových serverů pro implementaci aplikace. Každý z nich má své výhody a nevýhody, specifická řešení a přístupy. Uvádím zde krátký seznam těch v praxi nejběžněji se vyskytujících:

\begin{itemize}
\item Webový server Apache2 s programovacím jazykem PHP
\item Java Servlets, Java Spring Source
\item C\# s technologií .NET
\item Ruby on Rails
\item Python a Django
\item a mnohé další
\end{itemize}

\sekce{Ajax a webové služby}
Ajax, neboli Asynchronous JavaScript and XML, se dnes stává nedílnou součástí při vývoji webových aplikací. Aplikace tak dostávájí interaktivnější charakter bez nutnosti znovuzaslání celého požadavku webové aplikaci. Celý tento přístup probíhá nejvíce na straně klienta. Je použito javascriptu pro programovou implementaci, který má přístup ke stromu objektů dokumentu zvaného DOM, neboli Document Object Model. Do aplikační vrstvy jsem se rozhodl přidat AJAX z toho důvodu, že používá objekt XMLHttpRequest pro komunikaci s aplikačním serverem. Tyto aplikační požadavky jsou nazývány webovými službami pro Ajax. Tyto požadavky jsou vykonávány na aplikační vrstvě a představují potenciální zátěž, která musí být i v některých případech optimalizována.\cite{ajax}



% Databaze
\kapitola{Dabázová vrstva}
Úkolem databázové vrstvy ve webové architektuře je zajišťovat datové služby a uchovávat tak aplikační data perzistentní. V oblasti webových architektur se nejčastěji vyskytují relační databázové systémy, a proto i má práce je soustředěna na tento typ databázových systémů. Databázový systém obecně tvoří databáze, jakožto skupina strukturovaných homogenních souborů, a SŘBD, neboli Systém řízení báze dat, jakožto integrovaný softwarový prostředek řídící bázi dat.

\sekce{Optimalizace SQL dotazů}
Optimalizace dotazů SQL je nedílnou součásti procesu práce s databázovým systém v prostředí vysoké zátěže. Je totiž důležité nejenom si umět získat potřebná data, ale je potřeba zvážit i za jakou cenu tyto data prostřednictvím databázavého systému získáváme. Hovoříme-li o webových architekturách s vysokou zátěží, je tento proces optimalizace velice důležitý. Každá operace, každý dotaz, každá akce potřebuje ke své realizaci určité hardwarové a systémové prostředky, a v prostředí vysoké zátěže je důležité ušetřit co nejvíce těchto prostředků.

K tomu, abychom mohli vůbec přistoupit k optimalizaci SQL dotazů, je potřeba určit a identifikovat, které tyto dotazy jsou opravdu náročné na prostředky a čas, neboli mají vysokou cenu. K tomu slouží tzv profilery (viz. kapitola \ref{sec:profiler}). Profilery mohou být určeny pro aplikační vrstvu, kde profilují nejenom zdrojové kódy aplikace, ale samozřejmě i databázové dotazy, které jsou z této aplikační úrovně spuštěny. Tímto způsobem je možné získat přehled všech operací, které probíhají na aplikační i databázové vrstvě, poněvadž tyto vrstvy spolu neúzce souvisí a spolupracují. Další možností je použít profiler určený přímo k databázové vrstvě. Takový profiler pak profiluje pouze databázovou vrstvu, jednotlivé databázové dotazy, jejich cenu, dobu trvání, a jiné další statistiky.

Každý SQL dotaz má nějaký svůj exukuční plán. Databázový systém po obdržení SQL dotazu vybírá z několika možných exekučních plánů ten nejoptimálnější, který je po té v databázi proveden. Při výběru exekučního plánu je brán v potaz výběr indexu a způsob skenu tabulek, vybraná spojení, aj. Exukuční plán je možné zobrazovat v mnoha databázových systémech pomocí EXPLAIN a identifikovat tak místa exekučního plánu, která mohou být kandidátem pro optimalizaci.\cite{optimalizace-sql}

Pro optimalizaci SQL dotazů je možné určit několik základních oblastí, na které je možné se zaměřit při konkrétní optimalizace určitého SQL dotazu:

\begin{itemize}
\item Normalizovaný databázový návrh
\item Vnořené SQL dotazy
\item Indexace, výběr indexu a způsob prohledávání
\item Výběr druhu a pořadí spojení
\item Způsob používání podmínek, klauzulí a operátorů
\end{itemize}

\sekce{Indexace}
Indexace je důležitá a nejefektivnější optimalizace dotazů SQL. Při průchodu dat tabulkou má databáze na výběr několik možností prohledání. První možností je prohledat všechny řádky tabulky podle sql podmínek. To je nazýváno obecně Full Table Scan, nebo také Sequence Scan, neboli sekvenční prohledávání. Další možností je pužití některého z indexů pro přístup k hodnotám namapovaných na jejich ROWID, které ukazuje na fyzické uložení. Toto prohledání bývá nazýváno jako Index Range Scan, nebo jen obecně Index Scan, neboli indexační prohledávání. Samozřejmě prohledávání tabulek pomocí indexace je výrazně rychlejší a tím pádem důležité pro opimalizaci SQL. \cite{optimalizace-sql}

Indexy jsou fyzicky i logicky uloženy v asociativních tabulkách, a díky tomu tak i odděleny od datových tabulek. Čili při smazání indexů se nesmiží ani nijak neovlivňí datové tabulky. Pouze se může zpomolit přístup k datům, který byl rychlejší pomocí těchto indexů. Tabulky s indexy jsou samozřejmě uloženy na disku, poněvadž jejich velikost je obrovská a nevešly by se do operační paměti RAM. Operační paměť a přístup k ní je daleko rychlejší než přístup k datům uložených na disku, a proto je potřeba volit nějaký vhodný algoritmus prohledání a přístupu k indexům, a od toho se odvyjí i název a druh používaných indexů. V každém databázovém systému samozřejmě naleznete některé typické a některé atypické druhy indexů. \cite{optimalizace-sql} Zde je krátký výběr možných indexů:

\begin{itemize}
\item B-tree - pro přístup pomocí Root-Node-List
\item Bitmap - pro výčtové sloupce
\item R-tree - typ indexu optimalizovaný pro geometrická data.
\item GiST - zobecněný vyhledávací strom
\item a další
\end{itemize}


\sekce{Partitioning}
Partitioning, který je občas do češtiny překládán jako segmentace, občas jako škálování, slouží v relačních databázových systémech k rozdělování tabulek a indexů do menších částí a komponent. Díky tomu je pak činnost databáze rychlejší a snadnější. Při této segmentaci tak může dojít k rozdělení tabulek i na více pevných disků či serverů. Tyto segmenty jsou na sobě nezávisle, ale přitom je k nim možné přistupovat přes tabulku, pro kterou byla segmentace vytvořena. Databázová tabulka a její vlastnosti, jako například referenční integrita nebo žádná redundance, jsou stále zachovány a fungují přes všechny její segmenty. Dokonce i když dojde k selhání či výpadku jednoho ze segmentů, ostatní jsou stále přístupné a je možné s nimi pracovat. Partitioning je možné provádět na několika úrovních a podle různých klíčů. U segmentovaných tabulek je tak důležité si rozmyslet jakou strategii si zvolit. 

Při vertikální segmentaci dojde k segmentaci podle definovaných sloupců databázové tabulky. Klíčem při tomto rozdělení je určení sloupečků, které se nepoužívají ve where klauzuli, nebo jsou prázdné či zřídka používané. 

Častěji používáným přístupem je horizontální segmentace tabulek, čili segmentace podle řádků. Zde se segmentují řádky, podle určité hodnoty databázového sloupce. To do jakého segmentu bude řádek tabulky vložen rozhoduje nějaký interval, či hodnota výčtu a nebo nějaká funkce.

Další možností je aplikační úroveň segmentace, která se ne často objevuje v souvislosti s Partitioning. Nejedná se totiž o segmentaci určité databázové tabulky, ale o segmentaci databáze. Část tabulek je umístěna na jednom serveru, část na dalším serveru, a tak dále.

Partitiong je důležitým nástrojem při optimalizaci databázové vrstvy v architektuře webových systémů v prostředí vysoké zátěže. Dá se totiž předpokládat, že se zvětšující se zátěží roste i počet záznamů tabulek, a tak se doba přístupu zvětšuje a prostředky zatěžují ještě víc. Tyto problémy dokáže vyřešit partitiong.
\cite{partitioning-db}

\sekce{Replikace}
Replikací rozumíme technologii, kdy je možné nasadit více databázových serverů v rámci jedné databáze. Jedná se tak o sdílení dat mezi více hardwarovými, softwarovými a jinými prostředky a jejich přenositelnost. Účelem replikace je tak dosáhnout vysoké dostupnosti databázového systému a škálování výkonu pro optimalizaci v prostředí vysoké zátěže. Obecně existují dvě základní varianty databázových replikací od kterých se odvyjí jejich další využití. Samozřejmě v závislosti na konkrétním databázovém systému pak existují další členění a nastavení. 

Replikace varianty master-slave je podporována ve většině databázových systémech. Jedná se o jednodušší tzv. jednosměrnou replikaci. V této variantě je určen autonomní prvek, jedna replikace, která akceptuje a zpracovává požadavky na změny. Takováto replikace nese název master. Prvek s názvem slave je věrnou kopií autonomního prvku master. Slouží pouze ke čtení a může jich být více pro jeden master. Jakmile master obdrží a zpracuje požadavek na změnu, tak jej po dokončení přenese na ostatní slave replikace.

Replikace typu master-master bývá označována jako obousměrná. To znamená, že jsou v rámci jednoho databázového systému minimálně dvě replikace typu master, které akceptují všechny druhy požadavků na změny i čtení a přenáší je vzájemně mezi sebou. Z této vlastnosti vyplývá, že může dojít ke kolizím, kdy například dvě replikace master zapisují do stejné tabulky. Takovéto kolize jsou nevyhnutelné, a je potřeba je řešit.

Způsob přenosu mezi jednotlivými replikacemi může být synchronní či asynchronní. U synchronního přenosu se čeká až se změny provedou na všechny ostatní repliky. Takovýto proces je časově náročný, ovšem na druhou stranu je celý databázový systém konzistentní jako celek. U asynchronního přenosu se nečeká na dokončení přenosu mezi ostatními replikacemi. Díky tomu je celý databázový systém rychlejší, ovšem může dojít k nekonzistenci, kdy na ostatní replikace ještě nejsou přenesena všecha data.

Administrace, nástroje a konfigurace replikací jsou zabudované v téměř každém databázovém systému. Je důležité ale poznamenat, že tyto nástroje nejsou mnohdy dostačujícími řešeními pro architektury v prostředí vysoké zátěže a je proto nutné používání jiných doplňkových nástrojů. Také je více než důležité říct, že v prostředí vysoké zátěže se webová architektura bez databázových replikací jen těžko obejde.\cite{replikace}

\sekce{Druhy relačních databází}
V dnešní době existuje několik druhů relačních databázových systémů. Každý z nich má své klady a zápory, ovšem princip a způsob práce těchto databází je v základu podobný. Uvádím zde přehled těch v praxi se běžně vyskytujících:

\begin{itemize}
\item Oracle
\item MySQL
\item PostgreSQL
\item MSSQL
\item Firebird
\item a mnoho dalších
\end{itemize}



% Web cache
\kapitola{Webové cache}
Webové cache jsou důležitou vrstvou pro rozšíření výchozí třívrstvé architektury. Jak už napovídá z názvu cache, jedná se o vyrovnávací paměť jejíž hlavní účel je zrychlit odpověď webové aplikace na požadavek klienta. Zároveň je důležité poznamenat, že nefunkčnost, zánik či pád cache vrstvy nesmí nijak ovlivnit chod apikace, která musí být funkční i nadále. Účel této vrstvy je pouze zrychlit přístup k datům či již jednou interpretovaných odpovědí webové aplikace.

Webová cache se tak nachází mezi klientem a aplikační vrstvou. Základní komunikace probíhá tak, že klient pošle HTTP požadavek, aplikační server ho příjme a navrátí HTTP odpověď. Při existenci cache vrstvy probíhá komunikace jiným způsobem. Klient pošle HTTP požadavek a webová architektura zjistí, zda-li je tento HTTP požadavek určen pro ukládání do cache paměti. Pokud ano, tak webová architektura zkusí získat odpověď z cache paměti. Když tuto odpověď v paměti nalezne, zašle jej přímo klientovi. V opačném případě je požadavek poslán do aplikační vrstvy architektury, která jej zpracuje, vytvoří odpověď kterou uloží do cache paměti a pošle klientovi. Při příštím stejném požadavku bude odpověď vrácena z paměti cache. Dojde-li ke změně dat, která jsou uložena v cache paměti, dojde k invalidaci uložených dat v cache paměti a celý proces začne od začátku s novým HTTP požadavkem.

Pro webové architektury v prostředí vysoké zátěže je tato vrstva nevyhnutelná. Odpovědi z cache vrstvy jsou daleko rychlejší, dokonce až mnohonásobně, než odpovědi z aplikační vrstvy. Ve své práci se zabývám právě různými druhy cache a z výsledků profilování a testování vyplývá, že jsou tato tvrzení pravdivá.

\obrazek
\vlozeps{../images/cache-process.png}{0.6}
\endobr{Diagram aktivit cache webových systémů}

\sekce{Typy obsahu}
Z pohledu ukládání do cache paměti je přístup a druh obsahu webové architektury rozdělen na dva typy. Obsah může být buď statického nebo dynamického charakteru. Jak už vyplývá z obecné teorie systémů, statický obsah je konečný, transaprentní a měněn podle předepsaných pravidel, zatím co dynamický obsah se mění v závislosti na čase a jiných nepředvídatelných pravidlech. Například invalidace u statického obsahu proběhne pouze jednou za deset minut. A i když je obsah změněn uprostřed tohoto intervalu, změna se projeví až v přelomu těchto pravidelných desetiminutových intervalů, tedy až po invalidaci. Obsah je tak celých deset minut statický a neměnný. Naopak dynamický obsah se může změnit kdykoli, nepředvídatelně, typicky na nějakou uživatelovu činnost a nebo podle času. Například při vložení komentáře se ihned změní seznam komentářů. U dynamické ukládání dat do cache paměti je tak potřeba se zaměřit především na jejich změnu, tedy na jejich invalidaci.

Z uvedených vlastností vyplývá, že správa cache paměti statického obsahu je jednodušší, kdežto správa cache dynamického přístupu je náročnější. Ve své práci ukazuji, analyzuji a testuji oba dva přístupy a srovnávám jejich přínos jak z pohledu aplikace, tak náročnosti na vybudování.

\sekce{HTTP hlavičky pro ovládání cache}
Komunikace ve webových aplikacích probíhá ve valné většině na úrovni protokolu HTTP. Každý HTTP požadavek obsahuje HTTP hlavičky, kterými určuje požadavek, klienta a obsahuje časové razítko. Odpověď na tento požadavek navrací v hlavičkách návratový kód, informace o serveru, časové razítko, typ obsahu odpovědi, délku odpovědi a informace pro případné ukládání do cache paměti. Právě jednotlivé cache hlavičky jsou důležité pro nastavení ukládání a invalidace do proxy cache paměti nebo do reverzní proxy cache paměti.

Existují dva základní modely pro určení práce s cache vrstvou. Prvním je expirační model. Tento model určuje, do kdy je platná HTTP odpověď, neboli do kdy může tuto odpověď cache vrstva ukládat a označovat ji jako platnou a stále čerstvou. Tento model může být realizován dvěma způsoby. Prvním je hlavička "Expires" udávající časové razítko do kdy je odpověď čerstvá. Druhým, novějším, daleko flexibilnější a konfigurovatelnější způsobem je použití "Cache-control". Díky tomuto způsobu je možné určit další parametry a to nejenom do kdy je daná HTTP odpověď platná. Je možné tím i určit, zda-li je určena jen pro sdílené cache (proxy cache), nebo jen pro uživatelské prohlížečové cache, nebo zda-li je ukládat či nikoli, atd.\cite{rfc-http}

Druhým modelem je model validační. Ten určuje způsob komunikace pro zjištění, zda-li je odpověď uložená v cache paměti stále validní. Základem je, že cache, která má uloženu odpověď se zeptá je-li odpověď stále validní a server odpoví jestli ano či vrátí novou čerstvou odpověď. Realizováno to může být opět dvěma způsoby. Tím prvním je určení tzv. "Last-Modified". Při prvním požadavku cache získá odpověď s touto hlavičkoku. Odpověď si uloží a při dalším požadavku se cache vrstva dotáže serveru pomocí hlavičky "If-Modified-Since" s časovým razítkem, zda-li je odpověď stále validní. Server odpoví návratovým kódem 304, který říká že nedošlo k žádné změně od daného časového razítka, a nebo vrátí novou čerstvou odpověď pokud došlo ke změně. Podobný princip je založen i na způsobu pomocí hlavičky "Etag" neboli "Entity tag". Etag je nějaký unikátní identifikátor vygenerovaný serverem pro danou HTTP odpověď. Cache vrstva si při prvním požadavku uloží odpověď s tímto Etag. Při dalším požadavku pošle na server HTTP požadavek s hlavičkou "If-None-Match" s tímto Etag. Pokud se Etag shodují, vrátí aplikačnín server odpověď s návratovým kódem 304, a nebo celou čerstvou odpověď.\cite{rfc-http}

Ovládání pomocí HTTP hlaviček slouží hlavně k statiskému obsahu. Pro tento účel je pak dobré zvážit jestli je lepsí odpovědi měnit v nějakých časových intervalech a používat tak expirační model, či jestli se nevyplatí nasazovat model validační, který nese složitější administraci.

\sekce{Druhy cache}
Ve webových architekturách exstuje několik druhů cache vrstev. Jejich členění se odvyjí od jejich účelu, pozici v architektuře a typu ukládaných dat. Tyto atributy mezi sebou neúzce souvisí. Základním členěním může být jejich pozice z pohledu internetu, a to na klientskou a serverovou část. Za klientskou část považujeme cache systém uživatelova prohlížeče, či systémovější proxy cache. Na straně serveru se vyskytují reverse proxy cache či distribuované cache.

\obrazek
\vlozeps{../images/cache-types.jpg}{0.6}
\endobr{Druhy cache webových systémů}

\podsekce{Proxy cache a cache prohlížeče}
Tyto druhy cache se týkají klientské části webové architektury, neboli části před internetem. Znamená to tedy, že odpověď na klientův požadavek je vrácena z cache paměti lokální sítě, a tento požadavek vůbec nevstoupí do internetu na vzdálený dotazovaný server. Tyto cache vrstvy zde nejsou jen pro to, aby zrychlily odevzvu na požadavek, ale také aby zmenšily odchozí komunikaci z lokální sítě. A to z toho důvodu, aby byla šířka pásma přístupná i jiným službám, a ušetřili se prostředky za odchozí komunikaci.

V dnešních moderních prohlížečích je práce s cache pamětí podporována. Cache prohlížeče může nastavovat, konfigurovat, či vymazat pouze uživatel, neboli klient sám. Tato paměť ukládá hlavně statický obsah, například obrázky, CSS soubory či JS soubory. Cache paměť najde své uplatnění například když jsou uživatelovi požadavky směřovány jedné webové aplikaci se stejným vzhledem, rozhranním a nebo částí funkcionalit. Takováto data mohou být ukládána do cache paměti na dlouhou dobu, a proto musí aplikace dbát na to, aby byla tato data z cache promazávána tak jak je opravdu potřeba. Jednou z možností je určit jinou url adresu pro stejný soubor, pomocí tzv. "Query string", například takto:

\begin{scriptsize}
\begin{verbatim}
<link rel="stylesheet" type="text/css" href="style.css?QUERY_STRING" media="all" />
\end{verbatim}
\end{scriptsize}

Proxy cache bývají budovány a instalovány providery a poskytovali připojení k internetu. Jejich záměr je jednoduchý. Jde o to snížit míru odchozí komunikace, nezatěžovat tolik šířku pásma a zmenšit tak náklady spojené s touto komunikací. Nejběžnějším nastavením těchto proxy cache pamětí bývá ukládání a invalidace obsahu v závislosti na HTTP hlavičkách přijaté odpovědi. Nainstalujeme-li například takovouto cache ve firmě či nějakém sídlišti s několika desítky, sty či dokonce až tisíci uživateli, je možné, že část z nich má každé ráno stejný požadavek na stejný zpravodajský server, tudíž mají i stejnou odpověď. A tak může být první odpověď uložena do cache paměti a těm dalším uživatelům může být odpověď servírována z proxy cache paměti.\cite{proxy-cache}

\podsekce{Reverzní proxy cache}
Reverzní proxy cache, někdy označovány jako tzv. "Gateway cache", mají podobný systém činnosti jako proxy cache. Mají za úkol ukládat statický obsah ve formě HTTP odpovědí a tyto odpovědi vracet nazpět odkud přišel jejich požadavek. Úkolem je tak pokud možno nepropustit požadavek dále na aplikační vrstvu, stejně jako úkolem proxy cache je pokud možno nepropouštět požadavek dále do internetu. Rozdíl mezi reverzní proxy cache a proxy cache spočívá v jejich pozici ve webové architektuře, a také v tom, kým jsou instalovány. Pozice reverzní proxy cache je na straně serveru, neboli blíže aplikační vrstvě architektury, tedy na druhé straně internetu, než odkud příchází požadavky klientů a kde jsou instalovány proxy cache. Reverzní proxy cache jsou instalovány samotnými administrátory a programátory webové aplikace. Jejich účel je zajistit rychlejší odezvu webové aplikace na HTTP požadavky klientů. Reverzní proxy cache jsou nedílnou součástí webové architektury v prostředí vysoké zátěže a bez jejich existence by jen těžko mohla být webová aplikace spolehlivá a rychlá.\cite{proxy-cache}

\podsekce{Aplikační distribuovaná cache}
Doposud byly popisovány cache paměti pro ukládání statického obsahu. Ovšem v praxi se od projektového vedení setkáme s požadavky na dynamické chování aplikace. Příkladem může posloužit opět situace s komentáři, kdy jeden uživatel vloží komentář k některému z článků. Tento komentář se musí okamžitě objevit v seznamu komentářů k článku. V případě statického obsahu, který se mění pouze v nějakých intervalech, může uživatel nabýt dojmu, že tento komentář se nepodařilo vložit a zkusí ho vložit znovu. Takovéto chování aplikace určitě není v souladu s dobrým chováním interakce mezi uživatelem a aplikací. K tomu, aby se dala data ukládat do cache a aplikace byla stále dynamická, slouží tzv. aplikační distribuovaná cache. HTTP požadavek je tak rozdistribuován mezi menší požadavky a mezi cache paměti.

Jak už vyplývá z názvu druhu této cache, o manipulaci s touto cache pamětí se stará aplikační vrstva. Standartně se ukládají do cache paměti ta data, k nimž je dlouhá doba přístupu, obvykle data z databáze. Účelem je tedy ušetřit spojení a dotazy nad databází. Jeden HTTP požadavek s konkrétní url je často rozdělen na několik požadavků do databáze, v závislosti na tom, o která data se jedná. Například v rámci jedné HTTP stránky může být databáze dotázána o požadovaný článek a seznam komentářů pod článkem. Databáze tak obdrží dva SQL dotazy, na které vrátí příslušná data z databáze. Aby se příště aplikace nemusela na tato data dotazovat, uloží si je do aplikační cache paměti.

Při ukládání takových dat do cache paměti aplikační vrstva určuje jak a kam mají být data uložena, a kdy a za jakých podmínek mají být invalidována. Při aplikaci této cache vrsty dochází k propuštění požadavku na aplikační servery, což znamená větší zátěž aplikační vrstvy. Reverzní proxy cache jsou v tomto směru nepoužitelné, slouží pouze pro statický obsah a všechny požadavky propouští dále na aplikační vrstvu.

Při práci s aplikační distribuovanou cache je důležité si uvědomit několik základních pravidel. Prvním pravidlem je ukládat data do cache paměti co nejmenší. Účelem je tak distribuovat jednotlivá data v různých kontextech. Dále je důležité ukládat data znovuzkonstruovatelná. Je důležité umět z cache paměti přečíst to, co do ní bylo uloženo. Nejlepší je ukládat data serializovaná. Dále je důležité dodržet jednoznačný a jasně definovaný klíč či jmenný prostor pro tato data. Je totiž důležité vědět kde a jak se ptát na data. Největším problémem je invalidace dat v cache paměti. Stejná data mohou být interpretována v různém kontextu. Například při vložení nového článku se změní data pro seznam všech nejnovějších článků, a také data pro seznam nejnovějších článků v dané rubrice. Aplikace má za požadavek dynamické chování, a tak musí být tento článek vidět ihned po vložení ve všech zmíněných kategorií. Čili musí dojít k invalidaci všech závislostí. Tento problém je označován jako invalidační kaskády, a proto je důležité konstruovat aplikaci tak, aby se těmto kaskádám vyhýbalo co nejvíce či s nimi počítat už pří návrhu aplikační cache vrstvy.

% Dalsi vrstvy
\kapitola{Další vrstvy aplikace}
K čemu jsou další vrstvy

\sekce{CDN}
Content delivery network obrázky a stream.

\sekce{NoSQL Databáze}
K čemu slouží a kde najdou své uplatnění.

\sekce{Vyhledávání}
Z vyhledávání se také dělá další vrstva.



% Virtualizace
\kapitola{Virtualizace}
Projekty dnes neběží vždy na jednom serveru, ale na více virtualizovaných serverech. Proč tomu tak je.


% Load balancing
\kapitola{Load balancing}
Nevím jestli k této kapitole se vůbec dostanu, uvidíme. Každopádně serverů bývá vždy několik a jak zajišťovat toto rozložení zátěže.


% Cloud computing
\kapitola{Cloud Computing}
Budoucnost projektů, startupů, vše řešeno cloudem. AWS




% Prakticka cast
\kapitola{Praktická část s experimenty a výsledky}
V praktické části se zaměřuji na testy, optimalizaci jednotlivých vrstev webové architektury v prostředí vysoké zátěže. Rozebírám zde jednotlivé vrstvy architektury, tedy aplikační vrstvu, databázovou vrstvu, reverzni cache vrstvu a aplikační distribuoavanou cache. Součástí práce nejsou pouze popis a charakteristika jendotlivých kroků optimalizace, ale i jejich výsledné statistiky a zátěžové testy. Hlavní částí praktické části je ovšem návrh a implementace aplikační úrovně plně podporující práci s aplikační distribuovanou cache. Dále je popsána i výsledná konfigurace a nastavení jednotlivých vrstev architektury. Výsledkem je tedy kompletní použitelná studie řešící problematiku webové architektury v prostředí vysoké zátěže.

% Popis aplikace a nastroju
\sekce{Vrstvy webové architektury}
Webová architektura sestává z klientské vrstvy, reverzní proxy cache vrsrtvy, aplikační vrstvy, aplikační distribuované cache a databázové vrstvy. Klientská část je tvořena jedním uživatelem s operačním systémem Linux Ubuntu a zátěžovým testovacím nástrojem Siege. Reverzní proxy cache vrstva je realizována programem Nginx. Aplikační vrstva se skládá z webového serveru Apache2 s programovacím jazykem PHP a s profilovacím nástrojem XHProf. Aplikační distribuovaná cache vrstva je tvořena programem Memcached. Databází je PostgreSQL. Všechny tyto vrstvy serverové části jsou vytvořeny na zvláštních serverech. Pro reverzní proxy cache a aplikační distribuovanou cache byl zvolen jeden server. Každý ze serverů je virtualiziován za pomoci virtualizačního nástroje VirtualBox. Celá webová architektura je konfigurována v jedné virtuální lokální síti 10.9.0.0/24 se statikým přidělováním IP adres. Rozhraní pro přípojení těchto virtualizovaných serverů do virtuální sítě je realizováno pomocí síťových mostů. Vzhledem k tomu, abych mohl ukázat velké poměrové rozdíly v jednotlivých krocích optimalizace v jednotlivých vrstvách architektury, rozhodl jsem se o velice slabé hardwarové vybavení jednotlivých serverů, která mají 512MB operační paměti RAM a jeden jednojádrový procesor s frekvencí 2GHz.

\obrazek
\vlozeps{../images/more-layers.png}{0.6}
\endobr{Vrstvy implementované webové architektury}

\sekce{Testovací a profilovací nástroje}
Proto, abych mohl všecha svá tvrzení a závěry řádně podložit a abych mohl identifikovat místa nutná pro optimalizaci, jsou potřeba určité testovací a profilovací nátroje. Pomocí profilovacího nástroje XHProf jsem vyprofiloval statistiky pro aplikační vrstvu. Udělal jsem rozbory exekučních plánu pro SQL dotazy pro databázovou vrstvu, aby byla vidět míra jejich míra optimalizace. Také bylo potřeba vytvořit prostředí vysoké zátěže.

\podsekce{XHProf}
K tomu, aby bylo možné profilovat programovací jazyk PHP, jsem zvolil profilovací nástroj XHProf. Tento nástroj byl vyvinut v programovacím jazyce C. Uvolněn byl pod open-source licencí Apache 2.0. Autorem tohoto profilovacího nástroje je společnost Facebook. Tento profilovací nástroj dokáže vyprofilovat nejenom dobu trvání jednotlivých metod a funkcí, ale i jejich procesorové či paměťové nároky. XHProf je možné provozovat na operačních systémech Linux, FreeBSD a Mac OS X.

Jeho instalace a konfigurace je jednoducha a bezproblemova. Stačilo mi si stáhnout instalační balíček s rozšířením, zkomipilovat a nainstalovat. Po instalaci jej bylo nutné zaregistrovat jako rozšíření pro php v konfiguračním souboru php.ini. Samotné použití je pak velice snadné. Na začátek php skriptu jsem přidal zdrojový kód s jeho aktivací a na konci php skriptu kód pro jeho vypnutí.

Výsledkem profilování je přehledná statistika jednotlivých metod a funkcí ve formátu HTML. Všechno v přehledné tabulce, ve které je možné měnit pohled výsledků profilování podle specifické metody či funce. V tabulce je možné pozorovat čas strávený vykonávání pouze dané funkce, čas strávený vykonávání i funkcí z ní volané, počet volání funkce, doba trvání, procesorové čas a paměťové nároky. Výsledkem může být i graf vygenerovaný z těchto statistik a ze závislostí mezi jednotlivými funkcemi.

Tento program je nenáročný a může být provozován i v ostrém provozu. Výsledky takového profilování jsou důležité k identifikaci problémových míst k optimalizaci, čili pro webovou architekturu v prostředí vysoké zátěže jsou nevyhnutelné.\cite{xhprof}

\newpage
Příklad použití XHProf profilování:
\begin{scriptsize}
\begin{verbatim}
<?php
// Enable profiling
if (extension_loaded('xhprof')) {
    include_once '/usr/local/lib/php/xhprof_lib/utils/xhprof_lib.php';
    include_once '/usr/local/lib/php/xhprof_lib/utils/xhprof_runs.php';
    xhprof_enable(XHPROF_FLAGS_CPU + XHPROF_FLAGS_MEMORY);
}

// Php code for profiling
...

// Disable profiling
if (extension_loaded('xhprof')) {
    $profiler_namespace = 'myapp';  // namespace for your application
    $xhprof_data = xhprof_disable();
    $xhprof_runs = new XHProfRuns_Default();
    $run_id = $xhprof_runs->save_run($xhprof_data, $profiler_namespace);
}
?>
\end{verbatim}
\end{scriptsize}

\podsekce{Siege}
Vzhledem k tomu, abych mohl nasimulovat prostředí vysoké zátěže jsem zvolil testovací nástroj Siege. Siege je tedy nástrojem pro testování webových aplikací a jejich doby odezvy v prostředí vysoké zátěže. Tento nástroj má opět lehkou a přívětivou instalaci, nachází se totiž v základních instalačních balíčcích pro operační systém Linux Debian. Siege je programem spouštěným z příkazové řádky. Jako každý program, tak i siege má samozřejmě svůj konfigurační soubor, který je důležité hlavně pro nastavení maximální prováděcí doby jednotlivých testů.

Volby parametrů tohoto příkazového programu jsou velice bohaté, ale přitom jednoduché pro pochopení a použití. Základními parametry jsou:

\begin{itemize}
\item c - počet simulovaných konkurentích uživatelů
\item d - interval zpoždění mezi jednotlivými uživatelskými požadavky
\item r - počet repetic pro zátěžové testy
\end{itemize}

Ve své práci jsem prováděl zátěžové testy simulováním deseti uživatelů, v intervalu od nuly do jedné sekundy ve třech repeticích. Spuštění vypadá takto:
\begin{scriptsize}
\begin{verbatim}
siege -d1 -c10 -r3 -v http://dp-xskrha.local/hello/Mendelu
\end{verbatim}
\end{scriptsize}


\podsekce{PostgreSQL Explain}
Pro konkrétní analýzu problémových SQL dotazů je potřeba identifikovat a analyzovat jejich exekuční plán. V databázi PostgreSQL a ve většině databázích k tomu slouží příkaz explain, který takto zobrazí exekuční plán. Ve své práci jsem analyzoval problémová místa pomocí XHProf profilování, ze kterého jsem zjistil, že všechna ploblémová místa souvisí s dotazi pro databázi. Po této fázi identifikace následovala fáze vysvětlení pomoc SQL dotazu explain.

Pomocí explain je možné vysvětlit všechny kroky exekučního plánu. Zjistíme tak jaký způsob prohledání byl zvolen, zda-li sekvenční nebo indexový. Dále je možné zjistit druh spojení, jestli merge join nebo hash join, apod. U jednotlivých kroků exekučního plánu je zobrazena jejich cenu, předpokládaný počet řádků a předpokládaný počet sloupců. Takto je možné identifikovat slabá místa exekučního plánu a provést tak možnou úspěšnou optimalizaci.\\
\\
\\ Ukázka analýzy exekučního plánu:
\begin{scriptsize}
\begin{verbatim}
explain analyze select * from film f where film_id in (select film_id from film_actor);
                                   QUERY PLAN
--------------------------------------------------------------------------------------------
Hash Join  (cost=117.26..195.78 rows=977 width=390) (actual time=21.067..26.570 rows=997 loops=1)
  Hash Cond: (f.film_id = film_actor.film_id)
  -> Seq Scan on film f  (cost=0.00..65.00 rows=1000 width=390) 
  	     (actual time=0.016..1.699 rows=1000 loops=1)
  -> Hash (cost=105.05..105.05 rows=977 width=2) (actual time=21.029..21.029 rows=997 loops=1)
    -> HashAggregate  (cost=95.28..105.05 rows=977 width=2) 
           (actual time=17.598..19.298 rows=997 loops=1)
       -> Seq Scan on film_actor  (cost=0.00..81.62 rows=5462 width=2) 
              (actual time=0.012..8.019 rows=5462 loops=1)
Total runtime: 28.020 ms
\end{verbatim}
\end{scriptsize}


% APC
\sekce{Aplikační vrstva PHP}
Ve své aplikační vrstvě jsem zvolil pro implementaci programovací jazyk PHP běžící na webovém serveru Apache.
Webový server Apache je jedním z nejrozšířenějších a nejpopulárnějším webovým serverem na internetu. Byl implementován v roce 1996 v jazyce C++. Jeho instalace, konfigurace a administrace není nikterak složitá. Na spoustě webových hostingů je dostupný v základní konfiguraci. Je to volně použitelný produkt, který obsahuje spoustu různých přídavných módů. Z těchto důvodů jsem ho vybral pro praktickou část své diplomové práce.

Programovací jazyk PHP se stal jedním z nejpoužívanějších programovacích jazyků pro svoji srozumitelnost, přenositelnost a jednoduchost. Je to dynamicky typovaný programovací jazyk, čili i z těchto důvodů je hodně ohebný. Plně podporuje OOP přístup, čili je možné vyžívat těchto technik včetně návrhových vzorů, které jsou pro složité webové aplikace v prostředí vysoké zátěže velice důležité.


\podsekce{Optimalizace pomocí APC}
Programovací jazyk PHP je sice jednoduchý na vývoj, čitelnost a dynamičnosti, ovšem jeho daň je právě náročnost. Tento jazy je interepretovaný jazyk, čili při jeho interpretaci dochází k překladu do "Opcode" PHP kompilátorem. Vzniká tak jakýsi mezikód, který je následně po skončení překladu vykonán.

K tomu, aby se nemusel pokaždé překládat stejný script PHP kompilátorem, je možné ho uložit do cache pro mezikód, neboli Opcode cache. K tomuto účelu slouží APC, neboli Alternative Opcode Cache. APC je rozšířením pro PHP vytvořené přímo samotnými tvůrci programovacího jazyka PHP. Toto rozšíření není nijak zvláště náročné na intalaci ani konfiguraci. Dokonce je k němu možné zprovoznit i webové rozhraní ukazující počet úspěšných či neúspěšných dotazů do cache a jiné další statistiky. Prostřednictvím APC programového rozhraní se dají do cache paměti ukládat i jiné další hodnoty, a to právě přímo ze zdrojových kódů. Úložištěm pro APC je operační paměť RAM. Z toho důvodu je tedy důležité, aby webserver Apache2 stále běžel zapnutý. Při restartu web serveru dojde k invalidace celé APC cache paměti.

Většina interpretovaných jazyků je překládána do nějakého mezikódu. Proto se při žádné změně zdrojových kódů dá využít už jednou zkompilovaných výsledků. Tato forma recyklace zkompilovaného mezikódu dokáže přinést velké výsledky při optimalizaci. U APC jsou tyto výsledky více než viditelné.

\podsekce{Dosažené výsledky}
Pro dosažení výsledků optimalizace aplikační vrstvy jsem vygeneroval prostředí vysoké zátěže deseti konkurenčních uživatelů s intervalem požadavků do jedné sekundy ve třech repeticích. Na aplikačním serveru tak vzniklo deset vláken Apache2 s PHP pro každého z uživatelů a celý procesorový výkon byl tak rozdělen rovnoměrně mezi jednotlivé vlákna po deseti procentech. Vytížení procesoru aplikačního serveru tak dosahovalo sta procent, čili maximálního vytížení. Tuto prostředí jsem nasimuloval jak pro neoptimalizované prostředí bez APC, tak i pro optimalizovné prostředí s APC. Pro každý požadavek docházelo ke zpracování celého MVC frameworku, čili ke zpracování mnoho funkcí a metod.

Z XHProf profilování jsem vyprofiloval výsledky pro jeden požadavek jak pro APC, tak i bez APC. Výsledky toho profilování jsou takovéto:

\begin{itemize}
\item neoptimalované - bez APC - 1,3s
\item optimalizované - s APC - 0,4s
\end{itemize}

Z výsledku vyplývá, že při optimalizaci aplikační vrstvy pomocí APC došlo k zrychlení provedení PHP skriptů o více než padesát procent, a to jak při jediném požadavku, tak i v prostředí vysoké zátěže. Takovýto fakt se dá určitě označit úspěšnou optimalizací. Alternativou může být použití přístupu s webovým serverem Lighttpd a s cache pamětí pro mezikód eAccelerator. Výsledky by měli být hodně podobné. V dnešních dnech se objevují a publikují zprávy o uvolnění HIP-HOP pro PHP od společnosti Facebook. HIP-HOP používá úplně jiného přístupu pro zrychlení běhu PHP scriptů. Tato varianta je dnes ještě hodně čerstvá a ne tak prověřená, ovšem představuje další možnosti pro optimalizaci aplikační vrstvy v prostředí vysoké zátěže v budoucích dnech.

\obrazek
\vlozeps{../images/graph-apc.png}{0.4}
\endobr{Graf s výsledky doby trvání jednotlivých požadavků pro repetice}

\obrazek
\vlozeps{../images/top-apc.png}{0.4}
\endobr{Výpis systémových procesů aplikačního serveru}

\clearpage

% Databaze
\sekce{Databázová vrstva}
Databázová vrstva je důležitou a nezbytnou součástí webové architektury. Její úloha je perzistence dat pomocí databázového systému. Ovšem přístup k datům může být někdy velice zdlouhavý, až v řádech několik minut a hodin. V prostředí vysoké zátěže dochází obvykle k obrovskému růstu dat a je potřeba nastavit optimalizovat databázovou vrstvu tak, aby jejich doba přístupu byla co nejkratší.

Ve své práci jsem vytvořil databázi nad databázovým systémem PostgreSQL. Tento systém je volně dostupný a najde velké uplatnění právě ve webových architekturách. Podporuje všechny standartní databázové operace a přístupy a je oblíben pro svoji spolehlivost.

Databáze modelované aplikace obsahuje záznamy v řádech miliónů řádků. To z toho důvodu, aby bylo nasimulováno prostředí vysoké zátěže i s velkou databází. Datové záznamy byly pro potřeby mé práce vygenerovány a nepředstavují žádnou paralelu s reálnými daty.

\podsekce{Optimalizace databáze}
Před samotnou optimalizací databázové vrstvy nebyla databáze žádným způsobem optimalizována, ať už za pomocí indexace, optimalizace SQL dotazů, segmentování či vytvoření replikací. Přístup k datům v databázi také nebyl žádným způsobem efektivní. Jednalo se o znovu se opakující dotazy a dokonce místo jednoho SQL dotazu se objevovalo více dotazů pro zjištění stejné inforační hodnoty. Rozhodl jsem se tedy pro aplikování kroku optimalizace databázové vrstvy pomocí optimalizace dotazů SQL.

Pří procesu optimalizace jsem si napřed určil problematické sql dotazy pomocí XHProf profilování. Z tohoto procesu jsem zjistil které sql dotazy je potřeba zoptimalizovat. Dalším krokem následoval rozbor jejich exekučního plánu, vyhledání řešení a jeho aplikace. Řešením optimalizace některých z exukučních plánů byla indexace příslušných sloupců pro nahrazení sekvenčního prohledání za indexové prohledání. Zde je ukázka rozboru neoptimalizovaného exekučního plánu se sekvenčním prohledáním:

\begin{scriptsize}
\begin{verbatim}
SELECT * FROM dp_comment WHERE article_id = 15 ORDER BY create_time DESC;
-------------------------------------------------------------------------
Sort  (cost=121201.07..121201.08 rows=3 width=540) (actual time=16300.440..16300.444 rows=3 loops=1)
  Sort Key: create_time
  Sort Method:  quicksort  Memory: 20kB
  ->  Seq Scan on dp_comment  (cost=0.00..121201.05 rows=3 width=540) 
          (actual time=13.531..16300.393 rows=3 loops=1)
        Filter: (article_id = 15)
Total runtime: 16300.526 ms
\end{verbatim}
\end{scriptsize}

Po optimalizace je vidět, že sekvenční prohledání bylo odstraněno a nahrazeno indexovým prohledáním, které je daleko efektivnější:

\clearpage
\begin{scriptsize}
\begin{verbatim}
SELECT * FROM dp_comment WHERE article_id = 15 ORDER BY create_time DESC;
-------------------------------------------------------------------------
Sort  (cost=8.47..8.48 rows=3 width=540) (actual time=0.119..0.134 rows=4 loops=1)
  Sort Key: create_time
  Sort Method:  quicksort  Memory: 21kB
  ->  Index Scan using dp_comment_article_id_fk_i on dp_comment  (cost=0.00..8.45 rows=3 width=540) 
          (actual time=0.043..0.068 rows=4 loops=1)
        Index Cond: (article_id = 1441)
Total runtime: 0.303 ms
\end{verbatim}
\end{scriptsize}

\podsekce{Dosažené výsledky}
Při optimalizaci dotazů jsem důkladně prozkoumával exekuční plány jednotlivých dlouhotrvajících SQL dotazů. Na spoustě místech byly řešitelné pomocí indexace. Abych tyto kroky potvrdil i pro prostředí vysoké zátěže, rozhodl jsem se nasimulovat prostředí vysoké zátěže opět pomocí programu siege, který vytvořil deset konkurenčních uživatelů s intervalem požadavku do jedné sekundy a ve třech repeticích. Test proběhl samozřejmě před i po kroku optimalizace.

\obrazek
\vlozeps{../images/graph-db.png}{0.4}
\endobr{Graf s výsledky doby trvání jednotlivých požadavků pro repetice}

\obrazek
\vlozeps{../images/xhprof-model-db-no-optim.png}{0.4}
\endobr{XHProf profilování aplikačního modelu databázových dotazů před optimalizací}

\obrazek
\vlozeps{../images/xhprof-model-db-optim.png}{0.4}
\endobr{XHProf profilování aplikačního modelu databázových dotazů po optimalizací}

\clearpage

Z výsledků experimentu vyplývá, že SQL dotazy, které trvaly několik řádů sekund se zoptimalizovali až pod dobu jedné sekundy. Z grafu v prostředí vysoké zátěže je vidět, že před optimalizací byla maximální doba jednoho požadavku až 420 sekund. Celý proces byl hodně nestabilní a kolísavý. Po optimalizaci je viditelné ustálení činnosti databázového systému a zmenšení doby odezvy. Zrychlení je vidět až o více než padesát procent. Dalšími budoucími řešeními, která se by se dala aplikovat mohou být segmentace či replikace. Samotná optimalizace SQL dotazů řeší určité problémy, ovšem databáze může přerůst až do takových rozměrů, kdy je potřeba sáhnout k těmto řešením.

Databázová vrstva bývá velice často největším zdrojem zpomalení. Dotazy na tuto vrstvu jsou nejnáročnější ze všech procesů skrze celou webovou architekturu. Proto je velice důležité tento proces nepodceňovat a věnovat tomu patřičné prostředky.

% Memcached
\sekce{Aplikační cache}
Tady se budeme snažit optimalizovat databázy.

\podsekce{Optimalizace aplikace pomocí Memcached}
Co jsem udělal s Memcached, jednotlivé vrstvy modelu, popis toho čeho chci dosáhnout.

\podsekce{Diagram tříd pro aplikaci s podporou Memcached}
Diagram tříd mé aplikace

\podsekce{Dosažené výsledky}
Toto bude vždy na konci každého experimentu, grafy, časy, screeny, apod.

% Reverse Proxy Cache
\sekce{Reverzní proxy cache}
Tady se budeme snažit použít reverzní proxy cache.

\podsekce{Nasazení a konfigurace NGINX s Memcached}
Jak jsem co dělal s NGINX, problémy, řešení, návrh architektury a jak to ovlivňuje aplikační vrstvu

\podsekce{Význam Ajax a webových služeb pro NGINX}
Ajax komunikuje s NGINX, proč a jak.

\podsekce{Dosažené výsledky}
Toto bude vždy na konci každého experimentu, grafy, časy, screeny, apod.



% Diskuze
\kapitola{Diskuze}
Diskutovaná řešení, jak je možné je kombinovat, apod.



% Zaver
\kapitola{Závěr}
Závěr ve smyslu nákladů a přínosů, kdy je lepší co. Uvidíme, napíšu jako poslední.





\begin{literatura}

\citace{sledovani-zatizeni}{Kyle Rankin, 2010}{\autor{Kyle Rankin}
\nazev{Linux Journal: Hack and / - Linux Troubleshooting, Part I: High Load} [online]. Dostupné z: http://www.linuxjournal.com/magazine/hack-and-linux-troubleshooting-part-i-high-load}

\citace{dos}{Faisal Khan, 2009}{\autor{Faisal Khan}
\nazev{DOS ATTACKS: Dos Attacks Overview - What are DoS attacks} [online]. Dostupné z: http://dos-attacks.com/what-are-dos-attacks/}

\citace{anonymous}{Pavel Čepský, 2012}{\autor{Pavel Čepský}
\nazev{Lupa.cz: Útoky jménem Anonymous: Jak se rodí hackeři?} [online]. Dostupné z: http://www.lupa.cz/clanky/utoky-jmenem-anonymous-jak-se-rodi-hackeri/}

\citace{tri-vrstvy}{Jaroslav Zendulka, 2005}{\autor{Doc.Ing.Jaroslav Zendulka,CSc.}
\nazev{VUT-FIT: 10. Architektura klient/server a třívrstvá architektura} [online]. Dostupné z: http://www.fit.vutbr.cz/study/courses/DSI/public/pdf/nove/10\_clsrv.pdf}

\citace{ajax}{Brett McLaughlin, 2005}{\autor{Brett McLaughlin}
\nazev{Ibm develper works: Mastering Ajax} [online]. Dostupné z: http://www.ibm.com/developerworks/web/library/wa-ajaxintro1/index.html}

\citace{design-patterns}{Rudolf Pecinovský, 2007}{\autor{Rudolf Pecinovský}
\nazev{Návrhové vzory : 33 vzorových postupů pro objektové programování} 1. vyd. Brno: Computer Press, 2007. 527 s. ISBN 978-80-251-1582-4}

\citace{optimalizace-sql}{Bohdan Blaha, 2007}{\autor{Bohdan Blaha}
\nazev{SQL Optimalizace v Oracle} Praha: Unicorn College, 2010. 47 s. Dostupné z:
http://www.unicorncollege.cz/katalog-bakalarskych-praci/bohdan-blaha/attachments/Blaha\_Bohdan\_-\_Optimalizace\_SQL\_dotaz\%C5\%AF\_v\_datab\%C3\%A1zi\_Oracle.pdf}

\citace{partitioning-db}{Eli White, 2009}{\autor{Eli White}
\nazev{Habits of Highly Scalable Web Applications} DCPHP Conference 2009}

\citace{replikace}{Tomáš Vondra, 2011}{\autor{Tomáš Vondra}
\nazev{Replikace v PostgreSQL} CSPUG Konference 2011}

\citace{rfc-http}{RFC:2616, 1999}{\autor{R. Fielding, UC Irvine, J. Gettys, J. Mogul, Compaq, H. Frystyk, L. Masinter, Xerox, P. Leach, Microsoft, T. Berners-Lee, W3C/MIT}
\nazev{RFC:2616 - Hypertext Transfer Protocol -- HTTP/1.1}}

\citace{proxy-cache}{Mark Nottingham, 2012}{\autor{Mark Nottingham}
\nazev{CACHING TUTORIAL for Web Authors and Webmasters} [online]. Dostupné z: http://www.mnot.net/cache\_docs/}

\citace{xhprof}{Jakub Onderka, 2012}{\autor{Jakub Onderka}
\nazev{Zdrojak.cz: Profilování PHP skriptů pomocí XHProf} [online]. Dostupné z: http://www.zdrojak.cz/clanky/profilovani-php-skriptu-pomoci-xhprof/}


\end{literatura}



\end{document}